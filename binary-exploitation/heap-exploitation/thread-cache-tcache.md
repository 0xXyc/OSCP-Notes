---
description: 05/30/2024
cover: https://blog.kakaocdn.net/dn/bnVvwM/btqHiNEQH6Y/bLEN5jMMLPvzlvzCZQ7j20/img.png
coverY: 0
layout:
  cover:
    visible: true
    size: hero
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Thread Cache (Tcache)

## Introduction

This is a new technology implemented in glibc version 2.27 that is designed to boost performance and make heap management more efficient.&#x20;

More specifically, it is a per-thread memory allocation cache that is meant to improve the performance of `malloc()` and `free()` operations that are occurring within a given program.&#x20;

This works by reducing overhead and contention on global memory allocation structures (such as the main arena -- example pictured below). This is possible because these ultra-small, per-thread caches of freed memory blocks remain maintained throughout execution and can be reused very quickly.&#x20;

### Remembering how it works is very simple

<mark style="color:yellow;">For each chunk size</mark> (max = `0x410`), will get its own, dedicated, <mark style="color:yellow;">tcache</mark> bin. This can store up to <mark style="color:yellow;">seven chunks</mark>.

<figure><img src="../../.gitbook/assets/heap.png" alt=""><figcaption><p>Great heap illustration -- parking lot</p></figcaption></figure>

When a specific size is allocated, the tcache bin will be the first thing searched. When it is freed (`free()`), the chunk is added to the tcache bin.

However, if it is full, it then goes to the standard fastbin/unsorted bin.&#x20;

## Tcache Example

`tcache.c`:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocate memory
    char *ptr1 = (char *)malloc(32);
    char *ptr2 = (char *)malloc(32);

    // Use the allocated memory
    snprintf(ptr1, 32, "Hello, tcache!");
    snprintf(ptr2, 32, "Goodbye, tcache!");

    // Free the memory
    free(ptr1);
    free(ptr2);

    // Allocate again, reusing tcache
    char *ptr3 = (char *)malloc(32);
    char *ptr4 = (char *)malloc(32);

    // Use the reused memory
    snprintf(ptr3, 32, "Reused memory block!");
    snprintf(ptr4, 32, "Another reused block!");

    // Print the results
    printf("%s\n", ptr3);
    printf("%s\n", ptr4);

    // Free the memory
    free(ptr3);
    free(ptr4);

    return 0;
}
```

This code snippet will show how `malloc()` and `free()` interact with the tcache in C.

### Short Comings of The Tcache

Unfortunately, although the Tcache introduces major performance improvements, it also introduces new attack surfaces for memory corruption bugs.

**The bugs include:**

* <mark style="color:red;">**Tcache Poisoning**</mark>: An attacker can manipulate the tcache bins to create arbitrary write primitives, potentially leading to code execution.
* <mark style="color:red;">**Use-After-Free (UAF)**</mark>: UAF bugs will actually become easier because freed blocks will still be accessible in the tcache since it will act like a fastbin -- a singly-linked list of freed chunks of a specific size. The handling of the list using file descriptor (`fd`) pointers, is the same, meaning, that you can utilize the same attacks on the tcache that you can on fastbins.&#x20;

### Mitigations

* Pointer Authentication Code (PAC)
* Bounds Checking
* Randomization (PIE + ASLR)
