---
description: 10/16/2023
---

# 2âƒ£ Double Free

## Introduction

A double free occurs when freeing a resource more than once; this leads to memory leaks.

The allocator's data structures can get corrupted and then be controlled by an attacker.

<mark style="color:yellow;">This occurs when a pointer or address is freed twice</mark>.

This causes the program to freak out because the memory management for the program has become corrupted.

It is possible for `malloc()` to return the same pointer twice as a result (hence double free), find out what pointer gets returned by the `malloc()` call, malloc your data that was double freed or freed, and lastly your data will be called; resulting in code execution.

## Vulnerable Code Example

```c
a = malloc(10);     // 0xa04010
b = malloc(10);     // 0xa04030
c = malloc(10);     // 0xa04050

free(a);
free(b);  // To bypass "double free or corruption (fasttop)" check
free(a);  // Double Free !!

d = malloc(10);     // 0xa04010
e = malloc(10);     // 0xa04030
f = malloc(10);     // 0xa04010   - Same as 'd' !
```

We can see that a `fastbin` chunk will be freed twice here (second `free(a)`).

What is interesting here, is that with inserting a `free(b)` in the middle of our double free, we are essentially <mark style="color:yellow;">bypassing the double free/corruption (</mark><mark style="color:yellow;">`fasttop`</mark><mark style="color:yellow;">) security check</mark> implemented by `glibc`.

<mark style="color:yellow;">This is possible because we have freed another different chunk in between two frees</mark>.

