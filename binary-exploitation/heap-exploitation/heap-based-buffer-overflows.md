---
description: 10/16/2023
---

# Heap-based Buffer Overflows

## Introduction

Essentially, <mark style="color:yellow;">this can be easily explained as a buffer overflow that occurs on the heap portion of memory</mark>.

## Exploitation

#### **This can be possible by overwriting the adjacent heap metadata and data such as:**

* Objects
* Structs
* Function Pointers
* etc.

<mark style="color:yellow;">This can result in memory corruption and code execution</mark>.

## Example

**`heap-overflow.c`**:

```c
int main(int argc, char **argv[])
{
    char *ptr1, *ptr2;
    ptr = malloc(512);
    ptr2 = malloc(512);
    
    strcpy(ptr1, argv[1]);
    
    free(ptr2);
    free(ptr1);
    
    return 0;
}
```

When `free(ptr2)` is executed, the memory manager will freak out as the data has been corrupted.&#x20;

## Heap-Based Buffer Overflow w/ `malloc()` & `strcpy()`

`strcpy(b->buffer, argv[1]);`

`f->fp();`

If you are able to overwrite the function pointer (`fp`), you can overwrite it with whatever you want called and it will be called as it is a pointer.

This is <mark style="color:yellow;">essentially because we have control of the pointer</mark>.

## Metadata Corruption

This results in modifying or overwriting metadata and arrenges the heap in a way that points to your shellcode.

## More Coming Soon!
