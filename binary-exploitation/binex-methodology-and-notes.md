---
description: 07/28/2023
---

# ðŸ§¨ Binex Methodology & Notes

> _"Repetition is key, you need to keep working at this. Doing the same thing over and over again, rinse and repeat, similar to our pentesting methodology. Except this time, we are examining everything under an electron microscope at the binary level!"_&#x20;

## Tools

* [checksec](https://github.com/JonathanSalwan/ROPgadget)
* [Ropper](https://github.com/sashs/Ropper)
* [pwntools](https://github.com/Gallopsled/pwntools)
* Ghidra-auto -- Looking for link
* [pwndbg](https://github.com/Gallopsled/pwntools)
* [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)

## Methodology

<mark style="color:yellow;">Note</mark>: I will constantly be changing this for the next year or so.

1. <mark style="color:yellow;">See what the program is doing</mark>. <mark style="color:yellow;">Ask yourself these questions</mark>: How does it ingest data? Where does it store data? Where does the data go on the stack/memory? How much data do we need to get to the return address? Lastly, where do we want to divert execution to? -- Another function or our arbitrary code?
2. <mark style="color:yellow;">View & analyze</mark> source code if possible (rare, but not impossible). No source code? Utilize <mark style="color:green;">`ltrace <binary>`</mark> to see what is going on and give input if the program requires it. If the binary is on a remote server, use <mark style="color:green;">`strace`</mark> instead.
3. "<mark style="color:yellow;">Get a lay of the land</mark>..." run <mark style="color:green;">`file <binary>`</mark> to obtain details on the binary. Is the binary 32-bit or 64-bit? Is it statically or dynamically linked? Is the binary stripped or not stripped? Lastly, run <mark style="color:green;">`checksec <binary>`</mark> to view the defense mechanisms that were appended to the binary at compilation.&#x20;
4. <mark style="color:yellow;">Debugging</mark>: Time to get our hands dirty. This is where the real magic happens. We can throw our binary in <mark style="color:green;">`ghidra`</mark> to get a GUI view of what our binary is doing in memory. This helps at times. We can also use <mark style="color:green;">`pwndbg`</mark> as well.

## Miscellaneous

<mark style="color:green;">`pwn template`</mark> will give you a boiler plate template generated by <mark style="color:green;">`pwntools`</mark> for your exploit.

<mark style="color:green;">`ret addr`</mark> inside of <mark style="color:green;">`pwngdb`</mark> will print out stack addresses that contain return addresses.

Another way that we can find the return address is by using <mark style="color:green;">`ROPgadget`</mark> to print gadget information and looking for the return value (EAX, RAX, etc.):

```
ROPgadget --binary <binary> | grep eax
```

When we throw our program in <mark style="color:green;">`pwngdb`</mark>, we can manually fuzz the buffer using python:

```python
r << (python -c 'print "A" *150')
```

## <mark style="color:green;">`gcc`</mark> Compilation Notes

Compile with <mark style="color:yellow;">32-bit</mark> instruction set: <mark style="color:green;">`-m32`</mark>

Compile with <mark style="color:yellow;">64-bit</mark> instruction set: <mark style="color:green;">`-m64`</mark>

<mark style="color:green;">Enable</mark> stack protections: <mark style="color:green;">`-fstack-protector-all`</mark>

<mark style="color:red;">Disable</mark> stack protections: <mark style="color:green;">`-fno-stack-protector -z execstack -no-pie`</mark>

Enable <mark style="color:yellow;">debugging</mark>: <mark style="color:green;">-g</mark>&#x20;

<mark style="color:yellow;">Strip</mark> binary: <mark style="color:green;">`-s`</mark>

### Compiling a Binary w/ a Different Version of GCC w/ Docker

{% code overflow="wrap" %}
```
docker run --rm --mount type=bind,source="$(pwd)",target=/app -w /app gcc:10.5.0 gcc -Wall -g -fno-stack-protector -no-pie <BINARY.c> -o <BINARY-OUT>
```
{% endcode %}

#### Or, if you want PIE enabled:

{% code overflow="wrap" %}
```
sudo docker run --rm --mount type=bind,source="$(pwd)",target=/app -w /app gcc:10.5.0 gcc -Wall -g -fno-stack-protector -fPIE -pie <BINARY.c> -o <BINARY-OUT>
```
{% endcode %}

#### What is the reason for this?

<mark style="color:yellow;">Sometimes when we want to utilize certain ROP gadgets for our exploitation, we will require the usage of very specific gadgets</mark> such as `pop rdi, ret;` etc. and with newer versions of GCC, our binary will not be compiled with these useful gadgets. This gets around that.

## References

**Nightmare**:

{% embed url="https://guyinatuxedo.github.io/" %}

**ir0nstone's Notes:**

{% embed url="https://ir0nstone.gitbook.io/notes/" %}

**The CryptoCat!!!!**:

{% embed url="https://www.youtube.com/playlist?list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94" %}

**PinkDraconian**:

{% embed url="https://www.youtube.com/playlist?list=PLeSXUd883dhjmKkVXSRgI1nJEZUDzgLf_" %}
