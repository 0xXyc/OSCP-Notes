---
description: 08/23/2023
---

# ret2libc

## Introduction

This is primarily the attack you will use when you notice that the <mark style="color:yellow;">NX protection</mark> is <mark style="color:green;">ENABLED</mark> on the binary that you are attacking. This means that <mark style="color:yellow;">you do NOT have an executable stack to mess around with</mark>. This is because <mark style="color:yellow;">the stack memory is protected with the no execute (NX) bit enabled</mark>.

**Why does this matter to us?**&#x20;

Well, in a typical stack-based buffer overflow, an attacker will be able to write their shellcode into the vulnerable program's stack and be able to execute it on the stack.

But, <mark style="color:yellow;">if</mark> the NX bit is <mark style="color:yellow;">ENABLED</mark>, we will <mark style="color:red;">not</mark> be able to execute our shellcode from the vulnerable program's stack.

**How does ret2libc work?**

<mark style="color:yellow;">This attack allows us to bypass the NX bit protection and divert the program's execution by re-using part of executable code found in the</mark> <mark style="color:green;">`libc`</mark> <mark style="color:yellow;">library</mark>. Note that this library is already automatically linked dynamically at compile time and loaded into the program's virtual memory space.

Let's reference this great diagram from **Red Team Notes**:

{% embed url="https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/return-to-libc-ret2libc" %}

<figure><img src="../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

Breakdown of what's going on:

1. <mark style="color:yellow;">The EIP</mark> is being <mark style="color:yellow;">overwritten</mark> with the address of the `system()` function found in the `libc` library
2. <mark style="color:yellow;">Right after the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark>, there's an address of the function `exit()`, this is so that once `system()` returns, the vulnerable program will jump to `exit()` which lives in the `libc` library as well. This is so that the vulnerable program will exit gracefully and as expected.
3. <mark style="color:yellow;">Right after the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`exit()`</mark>, there's a pointer to a memory location that <mark style="color:yellow;">contains the string</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`/bin/sh`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">which is the argument that will be passed to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to execute a</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`/bin/sh`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">shell for us,</mark> <mark style="color:green;">**granting us a shell**</mark>.&#x20;

We can see the NX bit is enabled on this 32-bit binary here:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Remember, this means anything that we inject on the stack traditionally, will NOT be executed.&#x20;

We will be referencing CryptoCat's tutorial on **ret2libc** for this explanation and guide:

{% embed url="https://www.youtube.com/watch?v=0CFWHjc4B-I" %}

## Enumeration

`checksec`:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

* 32-bit binary
* <mark style="color:green;">NX ENABLED</mark>

`file`:

{% code overflow="wrap" %}
```
secureserver: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ba7b32f02b9ce5948bcb57c33599de4ad17682de, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit&#x20;
* Dynamically linked, meaning that instead of including all the code for our functions in the program itself or a header file, we are linking to the `libc` library at compile time to do this for us
  * So, all of this code is stored on YOUR `libc` library
* This binary is not stripped, meaning that we still have all of our debugging symbols, making our life easier to reverse

## Ghidra

So, <mark style="color:yellow;">since we are</mark> **dynamically linking** <mark style="color:yellow;">to the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library this means that when we call a function found in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library</mark>, our program will access the <mark style="color:yellow;">Global Offset Table</mark> (GOT) and go to that GOT section and look to see what the address of the called function in the libc library. This will be different on every machine since there are different versions of `libc`. This means that we can <mark style="color:yellow;">RETURN to functions FOUND IN</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark>.

`libc` contains functions such as `system(`) and we can pass the argument `/bin/sh` and we can return to the `libc` library and start executing functions in there!!! Hopefully granting us a shell.&#x20;

You can actually see the GOT in Ghidra within the Program tree:

<figure><img src="../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

Let's look through our functions in our symbol tree to find a vulnerable function to target:

<figure><img src="../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

After some analysis, I have found a function containing the vulnerable and deprecated `gets()` function, this is now our target, <mark style="color:yellow;">`receive_feedback()`</mark>.

So let's check out the function and see if we can find a buffer size we can attack:

```c
void receive_feedback(void)

{
  char local_4c [68];
  
  puts("Please leave your comments for the server admin but DON\'T try to steal our flag.txt:\n");
  gets(local_4c);
  return;
}
```

So, we see a <mark style="color:yellow;">buffer size of 68</mark> from our decompilation code for `receive_feedback()`.

<mark style="color:yellow;">The next objective is to find the offset to the instruction pointer (EIP)</mark>.

Let's send a cyclic pattern of 100 characters to the buffer, we can utilize `gdb` for this:

{% code overflow="wrap" %}
```
cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```
{% endcode %}

<mark style="color:yellow;">Copy this and be ready to send it to the program</mark>.

<figure><img src="../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">**You might be asking yourself**</mark>: Why is our EIP address: `0x61616174`?

Well, that is because that is the hex value of "`taaa`"!

We can confirm this by running `hex` and passing "`taaa`" as the argument:

```
hex taaa
74616161
```

Okay, cool, but why is it backwards? This is because this binary is representing data backwards due to it using little-endian format.

From this, we can see that we begin to overwrite the EIP with our pattern at "`taaa`", so we can then use `cyclic -l taaa` to find our offset to EIP:

<figure><img src="../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

**So what if I told you there's even an easier way to find the offset to the instruction pointer?**

<mark style="color:yellow;">In Ghidra, if we go to our target function and we find our EBP, we can convert the hex value to decimal with a calculator and find the offset too!!!</mark>

<figure><img src="../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

We see that 0x4c is the hex value of our EBP.

Let's convert that to decimal:

<figure><img src="../.gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">We get 76, how crazy is that??</mark>

