---
description: 08/29/2023
---

# ✏ Overwriting Global Offset Table (GOT)

> We're really deep now. Here, we will be focusing on overwriting the Global Offset Table (GOT)! We are going to be using another format string vulnerability, but there will be no buffer overflow this time.&#x20;

## Introduction

The <mark style="color:yellow;">Global Offset Table</mark> (<mark style="color:yellow;">GOT)</mark> is a <mark style="color:yellow;">section of a computer program's memory that is used to enable computer program code that has been compiled as an ELF file to be ran correctly</mark>. Simply put, it is a section inside of the program (ELF) that holds addresses of functions that are dynamically linked.&#x20;

This is all independent of the memory address where the program's code or data is loaded at during runtime.&#x20;

The GOT is <mark style="color:yellow;">responsible for mapping symbols</mark> (human-readable identifiers when compiled) to their correct addresses to facilitate <mark style="color:yellow;">Position Independent Code</mark> (<mark style="color:yellow;">PIC</mark>) and <mark style="color:yellow;">Position Independent Executables (PIE)</mark>.

**So, where is the GOT located in memory?**

You can <mark style="color:yellow;">find the GOT being represented as the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got.plt`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">sections within the ELF file</mark> which are <mark style="color:yellow;">loaded into the program's memory at the start of execution</mark>.&#x20;

The Operating System's dynamic linker updates the GOT's relocations at program startup or when symbols are being accessed.&#x20;

**Dynamic Resolving**

<mark style="color:yellow;">This allows the function to be able to be located from a dynamic library with much more efficacy</mark>. The result is saved into the GOT so future function calls jump straight to their implementation bypassing the dynamic resolver.

Implications:

* The <mark style="color:yellow;">GOT contains pointers to libraries which are constantly moved around</mark> due to <mark style="color:yellow;">Address Space Layout Randomization</mark> (<mark style="color:yellow;">ASLR</mark>)
* The GOT is also <mark style="color:yellow;">writeable</mark>

**What is the **<mark style="color:yellow;">**Procedure Linkage Table**</mark>** (**<mark style="color:yellow;">**PLT**</mark>**)?**

<mark style="color:yellow;">Before a function's address has been resolved</mark>, the GOT will point to an entry in the PLT. This is a function on its own that is responsible for calling the dynamic linker with the name of the function that is to be resolved.&#x20;

**Something else to note:**

If the binary that we are targeting is compiled with <mark style="color:yellow;">FULL RELRO</mark>, we will <mark style="color:red;">NOT</mark> be able to use this specific technique on the target. However, if it is compiled with <mark style="color:yellow;">PARTIAL RELRO</mark>, <mark style="color:yellow;">we will be able to</mark>!

**What is RELRO?**

<mark style="color:yellow;">Relocation Read-Only</mark> (<mark style="color:yellow;">RELRO</mark>) is a protection to stop any GOT overwrites from taking place.&#x20;

**Partial RELRO:**

<mark style="color:yellow;">This will only move the GOT above the program's variables</mark>. <mark style="color:green;">However, this does not prevent format string overwrites</mark>.

**Full RELRO:**

<mark style="color:yellow;">This makes the GOT completely read-only</mark>, even <mark style="color:red;">format string vulnerabilities will not be able to overwrite anything</mark>. This is not default in binaries because of slow processing times since it will need to resolve all function addresses simultaneously.

### GitHub

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/09-overwriting_got" %}

### Video Reference

{% embed url="https://www.youtube.com/watch?v=KgDeMJNK5BU" %}
CryptoCat
{% endembed %}

### Other References

{% embed url="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html" %}

### Set Proper File Permissions

```
sudo chown root:root got_overwrite
sudo chmod 4655 got_overwrite
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
```

## Enumeration

`file`:

{% code overflow="wrap" %}
```
file got_overwrite
got_overwrite: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=57da01c938d00b9c9beb3a58299d8c64766d748c, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit Binary
* Dynamically linked to `libc`
* Not stripped

`checksec`:

```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   71 Symbols        No    0               2            got_overwrite
```

* Partial RELRO
  * This is pertaining to the vulnerability that we will be targeting
  * Maps the `.got` section as <mark style="color:yellow;">read-only</mark> (but not `.got.pl`t)
* <mark style="color:green;">Stack Canary is ENABLED</mark> -- Each buffer in the program will contain a stack canary value and the return address
  * Before the jump to the return address, the canary value is checked to ensure that it is the same original value, helping to mitigate against buffer overflow attacks
  * If the value is not the same, a stack smashing error will be issued; crashing the program
* <mark style="color:green;">NX is ENABLED</mark> -- So we do not have an executable stack

## Messing with the Program

<figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

We can see that our input is being directly reflected back at us presumably with `printf()` or something similar.&#x20;

There must be a `while(true)` loop going on because the program will infinitely await user-input and not exit.

<figure><img src="../.gitbook/assets/image (1) (1).png" alt=""><figcaption><p>Unable to segfault from overflow</p></figcaption></figure>

There seems to be some kind of buffer/`sizeof()` checking going on since we cannot overflow the buffer.&#x20;

## Reversing

Keep in mind that I renamed variables, added comments, etc.

`main()`:

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */

undefined4 main(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 20);
  setuid(0);
  setgid(0);
                    /* Vulnerable Functions -- Format String Bug */
  vuln();
  uVar2 = 0;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
                    /* Stack Canary -- __stakc_chk_fail_local indicates usage of canaries */
    uVar2 = __stack_chk_fail_local();
  }
  return uVar2;
}
```

* `setuid(0)` and `setgid(0)` are ensuring that our binary runs smoothly with root permissions
* We call `vuln()` and upon further analysis (which you will see below, we were able to identify a format string vulnerability)
* \_\_stack\_chk\_fail\_local() indicates usage of stack canary-protected binary

`vuln()`:

```c
/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

void vuln(void)

{
  int in_GS_OFFSET;
  char buffer [300];
  undefined4 local_10;
  
  local_10 = *(undefined4 *)(in_GS_OFFSET + 0x14);
  do {
                    /* fgets() is checking that the buffer is sizeof() the specified buffer.
                       Preventing buffer overflow. Also keep in mind canaries are enabled. */
    fgets(buffer,300,_stdin);
                    /* No format string was specified -- printf() format string bug identified */
    printf(buffer);
  } while( true );
}
```

* Instantiate a char-based buffer with size of 300-bytes
* fgets() is using sizeof() our buffer (300-bytes) and ensuring up to 300-bytes are being stored and nothing more
* `printf(buffer)` is a <mark style="color:yellow;">string format vulnerability</mark> because it is <mark style="color:yellow;">not specifying a format specifier as an argument</mark>
* `while( true )` allows the program to be infinitely looped

## Plan of Attack

<figure><img src="../.gitbook/assets/image (136).png" alt=""><figcaption></figcaption></figure>

Notice how we have a <mark style="color:yellow;">string format bug</mark> (<mark style="color:yellow;">Remember, this is because our</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`printf()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">does not utilize a format specifier</mark>.) <mark style="color:yellow;">we can input a value that will overwrite an element of the GOT, we can find the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`printf()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">in the GOT and overwrite it with the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark>.&#x20;

Since we are constrained to an infinite loop, what will happen is:

* We will loop around again
* Take an input from us
* Then, instead of calling `printf()` with the buffer, it will call system() with the buffer
* If our buffer is `"/bin/sh"`, this will call `"/bin/sh"`

## Understanding <mark style="color:yellow;">GOT</mark> vs <mark style="color:yellow;">Procedure Linkage Table</mark> (<mark style="color:yellow;">PLT</mark>), <mark style="color:yellow;">`GOT.PLT`</mark> and <mark style="color:yellow;">`PLT.GOT`</mark>

`.got`:

<mark style="color:yellow;">This is the Global Offset Table (GOT)</mark>. This is where the actual table of offsets are located as filled in by the linker for external symbols.

`.plt`:

<mark style="color:yellow;">This is the Procedure Linkage Table (PLT)</mark>. These are stubs that look up the addresses in the `.got.plt` section and either jump to the right address or trigger the code in the linker to look up the address.

`.got.plt`:

<mark style="color:yellow;">This is the GOT for the PLT</mark>. It contains the target addresses after they have been looked up or an address back in the `.plt` to trigger the lookup.&#x20;

`.plt.got`:

<mark style="color:yellow;">This contains code to jump to the first entry of the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`.got`</mark>.

<mark style="color:yellow;">The PLT and the GOT work together to perform linking</mark>.

For example, when you call `printf()` in C and compile it as an ELF binary, it is not only `printf()`. Rather, it is compiled as `printf@plt`. Which you can see in GDB:

<figure><img src="../.gitbook/assets/image (137).png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">The GOT is a massive table of addresses and these are the actual locations in memory of the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">functions</mark>.&#x20;

When the PLT gets called it will read the GOT address and redirect execution from there.

When the address is empty, it will coordinate with the `ld.so` (A.K.A. the dynamic linker/loader shared object) to get the function address and store it in the GOT.

#### Key Takeaways

Calling the <mark style="color:yellow;">PLT address of a function is the same as simply calling the function itself</mark>.

The <mark style="color:yellow;">GOT address contains addresses of functions in</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and the GOT is within the binary</mark>.

### Viewing the PLT in Action

After viewing the disassembly for a particular function, I was able to locate `fgets()`, set a breakpoint, and view the inside of the PLT inside of `gdb`. After stepping into it, we can see a jump instruction which is acting as a function pointer. This works as a dereference and will jump to the resulting address.

Remember, if ASLR is enabled on your machine, you will get different addresses each time you run the binary.

```
info functions
0x08049040 fgets@plt

b *0x08049040

r
```

We can see that since we set a breakpoint at our `fgets@plt` function, that is where our instruction pointer or `EIP` value will be left at until we continue execution.&#x20;

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

We can use the following command to explicitly view the instruction that places us in the <mark style="color:yellow;">`PLT`</mark>:

```
x/i $pc
or
x/i $eip

=> 0x8049040 <fgets@plt>:       jmp    DWORD PTR ds:0x804c010
```

We then see a <mark style="color:yellow;">`jmp`</mark> instruction to a specific address.

However, this is not an ordinary <mark style="color:yellow;">`jmp`</mark> instruction, this is what it looks like when a <mark style="color:yellow;">function pointer</mark> is being used.&#x20;

NOTE: This pointer is in the .got.plt section of the binary.

We can then view the dereference:

```
x/wx 0x804c010

0x804c010 <fgets@got.plt>:      0x08049046
```

follow the `jmp`:

```
x/2i $pc
=> 0x8049046 <fgets@plt+6>:     push   0x8
   0x804904b <fgets@plt+11>:    jmp    0x8049020
```

<figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

We can see that we immediately jumped to the next instruction. <mark style="color:yellow;">This is because we have not called</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">before and we need to trigger the lookup first</mark>.&#x20;

It will push the number `0x8` onto the stack and then <mark style="color:yellow;">call the routine to lookup the symbol name</mark>.&#x20;

This all happens in the beginning of the `.plt` section.&#x20;

Let's find out what this stub does:

```
x/2i $pc
=> 0x8049020:   push   DWORD PTR ds:0x804c004
   0x8049026:   jmp    DWORD PTR ds:0x804c008
```

We push the value of the second entry into `.got.plt` and then jump to the address stored in the third entry.

```
x/2x 0x804c004
0x804c004:      0xf7f4aa40      0xf7f25fe0
```

We can obtain our PID from our currently debugged binary running `info inferiors` inside of `pwndbg`.

```
info inferiors 
  Num  Description       Connection           Executable
* 1    process 12579     1 (native)
```

* PID is 12579

We can then read from `/proc/pid/maps` for more information.

```
 cat /proc/12579/maps
```

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

We can then see that the <mark style="color:yellow;">first entry points into the data segment</mark> of `ld.so` and the <mark style="color:yellow;">2nd into the executable region</mark>.

In other words, we are asking for information for the `puts()` symbol. These two addresses in the `.got.plt` section are populated by the linker/loader (`ls.so`) at the time it is loading the binary.

If we step through the instructions a few times using `ni`, we will ultimately get to `fgets()`.

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

```
info symbol $pc
fgets in section .text of /lib/i386-linux-gnu/libc.so.6
```

Let's print out our stack:

```
x/4wx $esp
```

<mark style="color:yellow;">We can actually get from main to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`fgets()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">very quickly just by using the disassembly</mark> of `puts@plt.`

```
disass 'fgets@plt'
Dump of assembler code for function fgets@plt:
   0x08049040 <+0>:     jmp    DWORD PTR ds:0x804c010
   0x08049046 <+6>:     push   0x8
   0x0804904b <+11>:    jmp    0x8049020
End of assembler dump.

x/wx 0x804c010
0x804c010 <fgets@got.plt>:      0xf7d3d690

info symbol 0xf7d3d690
fgets in section .text of /lib/i386-linux-gnu/libc.so.6
```

<figure><img src="../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

We can see a call to `fgets@plt` will result immediately in a `jmp` to the fgets address loaded via dynamic linking from `libc`.&#x20;

So, how did the .got.plt get updated? This is why the pointer in the beginning of the GOT was passed as an argument back to `ld.so` and `ld.so` did black magic and inserted the proper address into GOT to replace the previous address which was pointed to the next instruction in the PLT.

#### Okay great, but how can we exploit this?

<mark style="color:yellow;">Since our ultimate goal is to take control of the flow of execution of the program</mark>, we need to remember that the `.got.plt` <mark style="color:yellow;">section is a giant array of function pointers</mark>.

So, could we overwrite one of these and control execution from there?

Any memory corruption primitive that will let you write to an arbitrary address will allow you to overwrite a GOT entry.

Ultimately, `.got.plt` is very <mark style="color:yellow;">attractive for format string bugs and other arbitrary write exploits</mark>.

When your target binary lacks PIE, this will cause the `.got.plt` to be loaded at a fixed address.&#x20;

<mark style="color:yellow;">Enabling FULL RELRO will protect against these kinds of attack by preventing writing to the GOT, but will severely impact performance</mark>.&#x20;

## Exploitation
