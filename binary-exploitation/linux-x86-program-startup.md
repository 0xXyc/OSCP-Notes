---
description: 08/15/2023
---

# üåê Linux x86 Program Startup

## Reference

{% embed url="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" %}

## Introduction

**What is this one about?**

This is to help you understand how programs are loaded under Linux.

This will <mark style="color:yellow;">focus specifically on dynamically loaded x86 ELF files</mark>.

With that said, <mark style="color:yellow;">if your binary is statically linked, the details will be different</mark>.

**Why?**

This will let you <mark style="color:yellow;">understand how to debug issues that occur in your program before main starts up</mark>.

{% embed url="http://dbp-consulting.com/tutorials/debugging/images/callgraph.png" %}

## Let's Jump in

Start off by building the most simple C program possible:

```c
int main()
{}
```

We will then compile it and view the disassembly of it to see how we get to `main()`.

Compile:

```
gcc -g simple.c -o simple
```

If you don't want to view it in the terminal, you can save it to a file and open it up in another text editor:

```
objdump -d simple > simple.dump -m32
```

Please note that from the reference, which I totally agree with, will be starting from the order of execution rather than the order `objdump` will display. So, we will be starting with well, `_start`.

### How do we get to `_start`?

The second that you run a program the shell or GUI will perform a `execve()` syscall.

`execve()` <mark style="color:yellow;">will execute the program referred to by the pathname</mark>.

You can actually see this if you run an `strace` on any binary. This will be the first syscall made.

<figure><img src="../.gitbook/assets/image (81).png" alt=""><figcaption></figcaption></figure>

Ultimately, `execve()` will set up a stack for you, **push** `argc`, `argv`, and `envp`.

The file descriptors 0, 1, and 2 are stdin, stdout, and stderr.&#x20;

The loader will set up your relocations, call preinitializers, and once everything is ready, control is handed to your program by calling `_start()`.

#### Let's check out \_start in objdump

<figure><img src="../.gitbook/assets/image (82).png" alt=""><figcaption></figcaption></figure>

Walking through:

#### \_start

Ignore `endbr32` as this is just initializing the shadow stack for our program.&#x20;

`xor ebp, ebp` is a xor of itself, meaning that it will equate to zero. So the value of `ebp` is zero.&#x20;

`pop esi` will pop off the top of the stack. This will make `argc` go into `esi`.&#x20;

Note: We are not getting rid of argc, we are simply saving it and will push it back on the stack later.

We are now at `mov esp, ecx`. This will mov `argv` into `ecx` without moving the stack pointer.

Notice how the next few instructions are pushes. This is because we are aligning the stack variables are likely to be nicely aligned for memory and cache efficiency.&#x20;

#### Set up calling for \_libc\_start\_main

