---
description: 08/22/2023
---

# ðŸ‘¿ You know 0xDiablos

## Challenge

{% embed url="https://app.hackthebox.com/challenges/you-know-0xdiablos" %}

## Challenge Description

> I missed my flag

## Enumeration

`file`:

{% code overflow="wrap" %}
```
vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=ab7f19bb67c16ae453d4959fba4e6841d930a6dd, for GNU/Linux 3.2.0, not stripped 
```
{% endcode %}

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
```

Interesting, this binary was compiled with <mark style="color:red;">no memory protections</mark> whatsoever.

## Reversing

Load up vuln in `ghidra`.

We have a non-stripped binary, let's check out `main()`'s decompilation and disassembly.

`main()`:

```c
undefined4 main(void)

{
  __gid_t __rgid;
  
  setvbuf(_stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}
```

We can see a `setvbuf()` call that will open stream to change the block's buffer.

This means that information will appear on the destination file/terminal during it being written as long as it is unbuffered. Also, `fflush()` is commonly seen here, but we don't see it. This is to force out the block early.

The `puts()` call is simply just printing "`You know who are 0xDiablos:` " to the screen, immediately calling `vuln()` after and awaiting our input. This can be assumed that something in vuln() is being used to grab our STDIN.

So, we now know our next target/task, <mark style="color:yellow;">let's find out what's going on in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function</mark>.

`vuln()`:

```c
void vuln(void)

{
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}
```

We can see that we are allocating a char data-type buffer of 180-bytes.

* However, we do not know the variable due to the compiler simply not caring about variables

`gets()` is a deprecated function that is super dangerous because it will allow us to store characters on the stack past the buffer. We can see that whatever we send via STDIN will be sent directly to our buffer `local_bc` which is of 180-bytes. So, I'm thinking buffer overflow of sorts?

* It is recommended to use `fgets()` instead.&#x20;

There is then a call to `puts()` that will print our whatever we sent to the buffer. Thus, reflecting our STDIN back to the console.

Upon further analysis, flag() is another lucrative function that is being used to print out our flag.txt! So it is now clear that we must conduct a ret2win attack since there are no memory protections in play and flag() is not being called in main() or vuln(), meaning that it is still being loaded in memory, but never being called.&#x20;

<mark style="color:yellow;">But, what if we can divert execution to flag() rather than returning to main after completing the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`vuln()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function?</mark>
