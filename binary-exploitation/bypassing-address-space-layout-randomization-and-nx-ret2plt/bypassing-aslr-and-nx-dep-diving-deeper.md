---
description: 11/01/2023
cover: >-
  https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/cb0bfe2d-331e-4ca1-bf78-59c4c6c9ec9f/det7k5p-9c3b1eb1-00db-4ae4-8b0a-73681885a5a7.gif?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2NiMGJmZTJkLTMzMWUtNGNhMS1iZjc4LTU5YzRjNmM5ZWM5ZlwvZGV0N2s1cC05YzNiMWViMS0wMGRiLTRhZTQtOGIwYS03MzY4MTg4NWE1YTcuZ2lmIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.-ojm_d_6N552xMnbHwchqJgAwq2E7cJBxF2yF59PT6g
coverY: -2
---

# ðŸ¥· Bypassing ASLR & NX/DEP (Diving Deeper)

## Introduction

Hello! Here, we will be discussing bypassing Address Space Layout Randomization (ASLR) in greater depth.

Remember, <mark style="color:yellow;">ASLR will randomize the addresses in our dynamic libraries, stack, and heap</mark>. It will not touch our binary unless our binary is compiled with the Position Independent Executable (PIE) is enabled on the binary.

**We can actually confirm this by running `ldd` against our binary and notice that the addresses will change each time:**

```
ldd shell
	linux-vdso.so.1 (0x00007ffffdcdd000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdb9f400000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fdb9f7c8000)
	
ldd shell
	linux-vdso.so.1 (0x00007ffc64387000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fefad600000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fefad925000)
	
ldd shell
	linux-vdso.so.1 (0x00007ffc1affb000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f50af600000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f50afa40000)
```

## How-to: Bypassing ASLR

First, <mark style="color:yellow;">we will want to start off by locating a potential buffer overflow within our program</mark>.

Second, <mark style="color:yellow;">we will want to leak the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts()`</mark> with our buffer overflow using a `puts@plt()` and then we will be able to calculate the address of system() since we have access to our `libc` library.

Third, <mark style="color:yellow;">you will want to calculate the address of the "</mark><mark style="color:yellow;">`sh`</mark><mark style="color:yellow;">" string so that we can ultimately execute a call to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system("sh")`</mark>.

This does sound complicated, but we can make our lives easier on us by utilizing pwntools.

### Vulnerable Code

`aslr-1.c`:

```c
#include <stdio.h>

int main(int argc, char* argv[])
{
    char buffer[64];
    printf("Enter some data:\n");
    gets(buffer);

    printf("So, you think you can bypass the almighty ASLR protection?\n");

    return 0;
}
```

#### Compile:

```
gcc aslr-1.c -o aslr-1 -Wall -ansi -fno-stack-protector
```

### Enumeration

`file`:

{% code overflow="wrap" %}
```
file aslr-1
aslr-1: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=58bc036b95b49a6bb6aeb41ffa60eff8a95b2af6, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

`checksec`:

```
checksec aslr-1
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

### Exploitation

<mark style="color:yellow;">Since ASLR is enabled, we must understand how the Global Offset Table (GOT) works</mark> since we will not know where our addresses will be mapped to the dynamic library (`libc`) of our binary.

_<mark style="color:yellow;">The addresses are determined at runtime and the GOT will act as a "dictionary" of sorts to store our external addresses found in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library</mark>_.

These values within the GOT are determined by the dynamic address solver A.K.A. the linker.

So, for our exploit to work, <mark style="color:yellow;">we will need to reference GOT addresses instead of external addresses</mark>. We will want to pay close attention to the external function (found in the `libc` library)  , `puts()`, as it will be very lucrative to us. Note how `puts()` is not contained within our source code, but rather the dynamic library itself.

