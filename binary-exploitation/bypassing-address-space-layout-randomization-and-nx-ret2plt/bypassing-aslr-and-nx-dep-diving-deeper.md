---
description: 11/01/2023
cover: >-
  https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/cb0bfe2d-331e-4ca1-bf78-59c4c6c9ec9f/det7k5p-9c3b1eb1-00db-4ae4-8b0a-73681885a5a7.gif?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2NiMGJmZTJkLTMzMWUtNGNhMS1iZjc4LTU5YzRjNmM5ZWM5ZlwvZGV0N2s1cC05YzNiMWViMS0wMGRiLTRhZTQtOGIwYS03MzY4MTg4NWE1YTcuZ2lmIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.-ojm_d_6N552xMnbHwchqJgAwq2E7cJBxF2yF59PT6g
coverY: -2
---

# ðŸ¥· Bypassing ASLR & NX/DEP (Diving Deeper)

## Introduction

Hello! Here, we will be discussing bypassing Address Space Layout Randomization (ASLR) in greater depth.

Remember, <mark style="color:yellow;">ASLR will randomize the addresses in our dynamic libraries, stack, and heap</mark>. It will not touch our binary unless our binary is compiled with the Position Independent Executable (PIE) is enabled on the binary.

**We can actually confirm this by running `ldd` against our binary and notice that the addresses will change each time:**

```
ldd shell
	linux-vdso.so.1 (0x00007ffffdcdd000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdb9f400000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fdb9f7c8000)
	
ldd shell
	linux-vdso.so.1 (0x00007ffc64387000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fefad600000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fefad925000)
	
ldd shell
	linux-vdso.so.1 (0x00007ffc1affb000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f50af600000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f50afa40000)
```

## How-to: Bypassing ASLR

First, <mark style="color:yellow;">we will want to start off by locating a potential buffer overflow within our program</mark>.

Second, <mark style="color:yellow;">we will want to leak the address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts()`</mark> with our buffer overflow using a `puts@plt()` and then we will be able to calculate the address of system() since we have access to our `libc` library.

Third, <mark style="color:yellow;">you will want to calculate the address of the "</mark><mark style="color:yellow;">`sh`</mark><mark style="color:yellow;">" string so that we can ultimately execute a call to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system("sh")`</mark>.

This does sound complicated, but we can make our lives easier on us by utilizing pwntools.

### Vulnerable Code

`aslr-1.c`:

```c
#include <stdio.h>

int main(int argc, char* argv[])
{
    char buffer[64];
    printf("Enter some data:\n");
    gets(buffer);

    printf("So, you think you can bypass the almighty ASLR protection?\n");

    return 0;
}
```

### Compiling a Binary w/ a Different Version of GCC w/ Docker

{% code overflow="wrap" %}
```
docker run --rm --mount type=bind,source="$(pwd)",target=/app -w /app gcc:10.5.0 gcc -Wall -g -fno-stack-protector -no-pie aslr-1.c -o aslr-1
```
{% endcode %}

This downgrade is required so we can compile our binary with the correct gadgets.

### Enumeration

`file`:

{% code overflow="wrap" %}
```
file aslr-1
aslr-1: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=58bc036b95b49a6bb6aeb41ffa60eff8a95b2af6, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

`checksec`:

```
checksec aslr-1
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

### Exploitation

<mark style="color:yellow;">Since ASLR is enabled, we must understand how the Global Offset Table (GOT) works</mark> since we will not know where our addresses will be mapped to the dynamic library (`libc`) of our binary.

_<mark style="color:yellow;">The addresses are determined at runtime and the GOT will act as a "dictionary" of sorts to store our external addresses found in the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">library</mark>_.

These values within the GOT are determined by the dynamic address solver A.K.A. the linker.

So, for our exploit to work, <mark style="color:yellow;">we will need to reference GOT addresses instead of external addresses</mark>. We will want to pay close attention to the external function (found in the `libc` library)  , `puts()`, as it will be very lucrative to us. Note how `puts()` is not contained within our source code, but rather the dynamic library itself.

**Why do we care about `puts()`?**

Well, this is because <mark style="color:yellow;">calling</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">will allow us to output the external address of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts@libc`</mark><mark style="color:yellow;">, which will give us an idea of where our</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">dynamic library is mapped in memory</mark>.

#### Using `objdump`, we can view the address of `puts@GOT`:

`-R` will allow us to be able to view relocation records in our binary.

```
objdump -R aslr-1

aslr-1:     file format elf64-x86-64

DYNAMIC RELOCATION RECORDS
OFFSET           TYPE              VALUE 
0000000000003da8 R_X86_64_RELATIVE  *ABS*+0x0000000000001180
0000000000003db0 R_X86_64_RELATIVE  *ABS*+0x0000000000001140
0000000000004008 R_X86_64_RELATIVE  *ABS*+0x0000000000004008
0000000000003fd8 R_X86_64_GLOB_DAT  __libc_start_main@GLIBC_2.34
0000000000003fe0 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable@Base
0000000000003fe8 R_X86_64_GLOB_DAT  __gmon_start__@Base
0000000000003ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable@Base
0000000000003ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5
0000000000003fc0 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5
0000000000003fc8 R_X86_64_JUMP_SLOT  gets@GLIBC_2.2.5
0000000000003fd0 R_X86_64_JUMP_SLOT  __isoc99_scanf@GLIBC_2.7
```

Pay attention to the ninth row, this is where we want to direct our attention.

```
0x0000000000003fc0 R_X86_64_JUMP_SLOT  puts@GLIBC_2.2.5
```

From here, we will need a ROP gadget that will take a parameter from the stack and places it into the RDI register, which is the register that takes the first parameter.&#x20;

We want to place the first parameter using our `puts@plt` call.

#### Why do we want to do this?

This is because we are exploiting a binary that runs on an x64 architecture.

The x64 calling convention requires the first parameter of a call to be placed into the RDI register.

Specifically, we are looking for a <mark style="color:yellow;">ROP gadget</mark> that `POP`'s the value of `RDI` and `RET`'s (`POP RDI; RET`).

#### Finding ROP Gadgets

```
ropper --file aslr-1 --search "pop rdi"
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: aslr-1
0x00000000004011cb: pop rdi; ret;
```

You might be wondering how we would call `puts()`, this is a good question because we can <mark style="color:yellow;">call</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts@PLT`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">through the Procedure Linkage Table</mark> (PLT) "trampoline".

This works because <mark style="color:yellow;">this address is fixed and unaffected by ASLR</mark>.

#### Obtaining `puts@PLT` via `objdump`:

```
objdump -d -M intel aslr-1 | grep "puts@plt"
0000000000401030 <puts@plt>:
  401146:	e8 e5 fe ff ff       	call   401030 <puts@plt>
  401161:	e8 ca fe ff ff       	call   401030 <puts@plt>
```

```
0x0000000000401030 <puts@plt>
```

### Exploit Development

`aslr-1-exploit.py`:

```
```
