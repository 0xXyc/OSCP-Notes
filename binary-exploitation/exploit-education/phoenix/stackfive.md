---
description: 07/27/2023
---

# 5⃣ StackFive

<figure><img src="../../../.gitbook/assets/image (2).png" alt=""><figcaption><p>STACK FIVE!!!!</p></figcaption></figure>

> As opposed to executing an existing function in the binary, this time we’ll be introducing the concept of “shell code”, and being able to execute our own code.

**Hints**

* Don’t feel like you have to write your own shellcode just yet – there’s plenty on the internet.
* If you wish to debug your shellcode, be sure to make use of the [breakpoint](https://en.wikipedia.org/wiki/Breakpoint) instruction. On i386 / x86\_64, that’s 0xcc, and will cause a SIGTRAP.
* Make sure you remove those breakpoints after you’re done.

## Source Code

<pre class="language-c"><code class="lang-c">/*
 * phoenix/stack-five, by https://exploit.education
 *
 * Can you execve("/bin/sh", ...) ?
 *
 * What is green and goes to summer camp? A brussel scout.
 */

#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>
#define LEVELNAME "mylevel"

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

<strong>char *gets(char *);
</strong>
void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
</code></pre>

This challenge looks very similar to stack-four but it gives us a much larger buffer of 128-bytes to mess around with. Presumably for our shellcode.

## Compilation

I ran into some issues with this binary due to my shellcode not liking my environment, so just to make your guys' life easier, I recommend to compile stack-five with the following arguments:

```
gcc -g stack-five.c -o stack-five -fno-stack-protector -z execstack
```

This will remove stack protections such as canaries and executable stack spacing.

I also recommend to disable your ASLR while debugging:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

## Source Code Analysis

```c
char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

We can see that we have a data type of `char` that receives a pointer to the `gets()` function and stores our input as a `char *`.

We will then enter a `start_level()` function that will store our input within a `128-byte` buffer using `gets()`.

That's it! There are no other special functions going on here. Simply just main printing a defined banner and calling the `start_level()` function as mentioned above.

With that said, let's throw it in `pwndbg` and start debugging!

## Preperation

Since we are likely going to be messing around with buffers again, it is a good idea to throw data at the program in an attempt to find where the buffer is in memory.

We can do this similar to the method we used in stack-four using `python3`:

```
python3 -c 'print("A" *128)' > test2.txt
```

We can multiply our A by 128 to fill our 128-byte buffer.&#x20;

## pwndbg

The first thing I like doing when I start debugging a new program is to list out my functions:

```
info functions

All defined functions:

File stack-five.c:
25:	int main(int, char **);
20:	void start_level();

Non-debugging symbols:
0x0000000000001000  _init
0x0000000000001050  __cxa_finalize@plt
0x0000000000001060  puts@plt
0x0000000000001070  gets@plt
0x0000000000001080  _start
0x00000000000010b0  deregister_tm_clones
0x00000000000010e0  register_tm_clones
0x0000000000001120  __do_global_dtors_aux
0x0000000000001160  frame_dummy
0x00000000000011b8  _fini
```

We can see our two that we want to focus on, `main()` and `start_level()`.

Place a breakpoint at our `start_level()` and run our file with our file full of A's:

```
b start_level
Breakpoint 1 at 0x1175: file stack-five.c, line 22.

run < test.txt
```

<mark style="color:yellow;">Now there are some things that I want you to pay attention to</mark>:

<figure><img src="../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

<mark style="color:yellow;">Notice</mark> how we are on the breakpoint for `start_level()` where `gets(buffer)` is being called.

We see a <mark style="color:green;">`lea`</mark> instruction to store our offset of `[`<mark style="color:purple;">`0x80`</mark>` ``-`` `<mark style="color:blue;">`rbp`</mark>`]` in our <mark style="color:blue;">`rax`</mark> register.

* What is this doing? This is preparing our stack to allocate space for our buffer
* Also, <mark style="color:purple;">`0x80`</mark> is equivalent 128 in decimal, hence our 128-byte buffer

We then see a <mark style="color:green;">`mov`</mark> instruction to move the `buffer` stored in <mark style="color:blue;">`rax`</mark> to our <mark style="color:blue;">`rdi`</mark> register to be stored as an argument for our program.&#x20;

There is then a <mark style="color:green;">`call`</mark> instruction for `gets()` for our `buffer`.&#x20;

Isn't that cool? Let's dive in even deeper.&#x20;

### `start_level()` Prologue and Epilogue

We can better examine what is going on in our assembly code for `start_level()` with:

```
disass start_level
```

<figure><img src="../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

<mark style="color:blue;">Blue</mark>: end-branch (<mark style="color:yellow;">**shadow stack stuff**</mark>) -- we will not be worrying about this right now

<mark style="color:green;">Green</mark>: This is our <mark style="color:yellow;">**prologue**</mark> for `start_level()`

* Prepares the stack and registers to use the function -- establish the function's stack frame
* We can see a <mark style="color:green;">`push`</mark> instruction for the value of <mark style="color:blue;">`rbp`</mark> to be pushed onto the stack
  * This will push the base pointer onto the stack to be restored later
* We can then see a <mark style="color:green;">`mov`</mark> instruction for the value of <mark style="color:blue;">`rsp`</mark> to be stored in <mark style="color:blue;">`rbp`</mark>
  * In other words, take the top of the stack and put it in the bottom
* We are adding `0x80` to our rsp for our `buffer`
* We are loading the effective address (<mark style="color:green;">`lea`</mark>) for the offset of `[`<mark style="color:red;">`rbp-0x80`</mark>`]` and storing the value in <mark style="color:blue;">`rax`</mark> as our return value
* We are then using the <mark style="color:green;">`mov`</mark> instruction to move the value of <mark style="color:blue;">`rax`</mark> into <mark style="color:blue;">`rdi`</mark> as an argument
* Next, we simply have a <mark style="color:green;">`call`</mark> instruction to `gets()` to store the contents of our `buffer` finally
* Lastly, we have a <mark style="color:green;">`nop`</mark> instruction for CPU-based reasons to properly align memory and prevent errors
  * This instruction literally stands for no operation, and does nothing

<mark style="color:red;">Red</mark>: This is our <mark style="color:yellow;">**epilogue**</mark> for `start_level()`

* The point of the epilogue is to tear down the pre-existing stack frame
* In other words, to undo the prologue
* Reverse to the prologue, we will be taking the bottom and making it the top again where we can prepare to return to our `main()` function
* We see a <mark style="color:green;">`leave`</mark> instruction that will begin to tear down the stack frame
* So, <mark style="color:green;">`leave`</mark> is interesting as it will implicitly drop rbp so we can free space for local variables
* <mark style="color:green;">`Pop`</mark> <mark style="color:blue;">`rbp`</mark> off of the stack so we can restore values from before the prologue
* <mark style="color:green;">`ret`</mark> will return to `main()` by popping the previous stack frame off the stack and jump to it



