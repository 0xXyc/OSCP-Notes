---
description: 10/08/2023
cover: https://i.gifer.com/EgUx.gif
coverY: 0
---

# âš™ pwntools ret2libc GOT & PLT

## Introduction

Here we will be covering utilizing `pwntools` to attack a binary utilizing the _**ret2libc**_ technique.

## Reference

{% embed url="https://www.youtube.com/watch?v=kvfnLvSbnhc" %}

### GitHub Repository

{% embed url="https://github.com/JohnHammond/misfortune-ctf-challenge.git" %}
John Hammond Challenge Repo
{% endembed %}

### Setup

`sudo ./setup.sh`

Everything you will need is in `/play`.

Our target is `misfortune`.

It comes with a dynamic `libc` library that is linked to our binary, `libc.so.6`.

* This tells us we are likely going to do a ROP-based attack or a _**ret2libc**_.

**Start docker image:**

`sudo docker run -p 9999:9999 misfortune`

**Connect to docker image hosting binary (to emulate remote exploitation):**

`nc localhost 9999`

You can do this remotely or locally.&#x20;

**Install `patchelf`:**

`sudo apt install patchelf`

Grab `pwninit`:

{% embed url="https://github.com/io12/pwninit/releases" %}

`wget https://github.com/io12/pwninit/releases/download/3.3.0/pwninit`

### `pwninit`

_**Automates startup tasks for binary exploitation challenges.**_

## Enumeration

`checksec`:

```
Arch:     amd64-64-little
RELRO:    Full RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x400000)
```

`file`:

{% code overflow="wrap" %}
```
misfortune: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=0729571751a2707a4b3fddcefba1a045420d1d72, not stripped
```
{% endcode %}

## "Messing" w/ the Target Binary

1. <mark style="color:yellow;">Run the binary</mark> -- What is it's goal?
2. <mark style="color:yellow;">How does the target binary consume data?</mark>
3. We noticed that there is a `SIGALRM` that timeout the binary after a period of not receiving input.
4. <mark style="color:yellow;">Can we overflow the buffer?</mark> -- Yes.

`strace`:

We were able to identify the `SIGALRM` using `strace`.

<figure><img src="../../.gitbook/assets/image (161).png" alt=""><figcaption><p>Viewing <code>SIGALRM</code> w/ <code>strace</code> as a syscall.</p></figcaption></figure>

`ltrace`:

We were able to see `printf()` and `puts()` usage.

## Reversing

`main()`:

```c
undefined4 main(void)

{
  char buffer [16];
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  puts("Give me data plz: ");
  gets(buffer);
  return 0;
}
```

We see `gets()` this is where our buffer overflow is stemming from.
