---
description: 08/26/2023
---

# ðŸ¥§ Leaking/Bypassing PIE and libc Base (ret2system)

> We're going to start getting pretty deep, stick this one out with me. We can do this together!

## Introduction

### Reference

{% embed url="https://ir0nstone.gitbook.io/notes/types/stack/pie" %}

**What is PIE?**

<mark style="color:yellow;">PIE</mark>, or <mark style="color:yellow;">Position Independent Executable</mark>.

When this memory protection is enabled, this means that <mark style="color:yellow;">your program will be loaded into a different memory address each time</mark>.

This means that <mark style="color:yellow;">you will not be able to hardcode values such as function addresses and gadget locations without first finding out where they are</mark>.

**How can we bypass this protection?**

Just like anything else, nothing is 100% un-hackable.&#x20;

Binaries protected with PIE means that they are based around relative rather than the usual absolute addresses. <mark style="color:yellow;">This means that the locations in memory are randomized</mark>; but the offsets <mark style="color:yellow;">between different parts of the binary remain the same</mark>.

(e.g.) If you know that the function main is located `0x128`-bytes <mark style="color:yellow;">AFTER</mark> the base address of the binary, find the location of `main()`, and then subtract 0x128 from this to get the base address and you then can use this data for the addresses of everything else.

**How can we exploit a binary with PIE enabled?**

Simply put, <mark style="color:yellow;">all we need to do is find a single address and PIE will be bypassed</mark>. It is just another slight obstacle we will have to overcome to reach our goal. The rest will stay the same in the exploitation process.&#x20;

**How can we leak this address?**&#x20;

Remember back in [format-string-vulnerabilities.md](format-string-vulnerabilities.md "mention"), we were able to leak data off of the stack and from any address?

Be sure to check this out:

{% embed url="https://ir0nstone.gitbook.io/notes/types/stack/pie/pie-exploit" %}

Well, <mark style="color:yellow;">we can utilize format string bugs or other ways to read the value off of the stack</mark>.&#x20;

<mark style="color:yellow;">The value will always be a static offset away from the binary base, enabling us to completely bypass PIE</mark>.

NOTE:

<mark style="color:yellow;">The base address of a PIE executable will ALWAYS end in the hexadecimal characters</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`000`</mark>. This is because paging is being used to randomize things in memory which have a fixed size of `0x1000`.&#x20;

<mark style="color:yellow;">This is very useful for troubleshooting if your exploit is not working as intended</mark>.&#x20;

Check to see if the base address ends in `000` if your exploit is acting weird.

## **So, what will we be doing in this tutorial?**

We will be combining the last two techniques that we learned, [format-string-vulnerabilities.md](format-string-vulnerabilities.md "mention") and [ret2libc](ret2libc/ "mention")! <mark style="color:yellow;">We will be also bypassing the PIE protection</mark>.&#x20;

Ultimately, we need to find a way to leak the `libc` function to leak the base, and then find a way to the functions that we are most interested in.&#x20;

In this example, <mark style="color:yellow;">we will be leaking the PIE address to bypass PIE</mark>!

### Video Tutorial

{% embed url="https://www.youtube.com/watch?v=NAUA1EB-TZg" %}
CryptoCat
{% endembed %}

## Preperation

### Obtain Target Files

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/08-leak_pie_ret2libc" %}

### Setting Proper Permissions

```
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
sudo chown root:root pie_server
sudo chmod 4655 pie_server
```

## Enumeration

`file`:

{% code overflow="wrap" %}
```
pie_server: setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=358390e52d086a4d5ef65c02f2dff0796b81dc69, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 64-bit executable
* Dynamically linked to `libc`
* Not stripped

`checksec`:

```
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

* <mark style="color:green;">NX is enabled</mark>
* <mark style="color:green;">PIE is enabled</mark>

## "Messing around with the program"

Let's obtain some additional situational awareness and get a lay of the land just by seeing what the binary does and what it is asking for.&#x20;

What's the point of this program?

<figure><img src="../.gitbook/assets/image (128).png" alt=""><figcaption></figcaption></figure>

Haha, this is great. The developer is taunting us a little bit with the new PIE protection set in place.
