---
description: 07/25/2023
---

# A Tour of x86

## Questions

Note: All questions are regarding the `stage1.asm` file.

1. What is the value of dh after line 129 executes?
2. What is the value of gs after line 145 executes?
3. What is the value of si after line 151 executes?
4. What is the value of ax after line 169 executes?
5. What is the value of ax after line 199 executes for the first time?

## Walkthrough

We started by clearing out all of the registers:

```nasm
org 7C00h

bits 16

%define LOAD_ADDR 0x6000

_start:

  mov ah, 0
  mov al, 0
  mov ax, 0
  
  mov bh, 0
  mov bl, 0
  mov bx, 0
  
  mov ch, 1
  mov cl, 1
  mov cx, 0 ; These will get overwritten regardless after this instruction is executed so it does not matter if they are set to 1
  
  cmp ch, 1
  je .death
  jmp .next_test
  
.death:
    hlt ; Immediately kill the program and don't ever come back
    
.next_test:
  cmp cl, 0
  je .success ; If cl is 0, don't go to .death
  
  hlt
  
  .success
```

However, we can also write 0's to the registers via binary operators (and, or, not, xor, and more):

```nasm
  xor dh, dh  ; <- Question 1
  and dl, 0
  mov dx, 0xffff  ; Hexadecimal
  not dx

  cmp dx, 0
  jne .death
```

#### Question 1:

```nasm
xor dh, dh ; dh is xor'd by itself, equating to 0
```

**Answer**: `dh == 0` <mark style="color:yellow;">When you XOR (Exclusive OR) a value by itself, the result will always be 0.</mark>

<figure><img src="../../.gitbook/assets/image (74).png" alt=""><figcaption></figcaption></figure>

#### Question 2:

```nasm
mov dx, 0xffff ; 0xffff = 11111111
not dx, ; not = 0 -> 00000000
mov gs, dx ; 0 = dx -> dx -> gs
```

**Answer**: `gs = 0`

#### Question 3:

```nasm
mov cx, 0 ; cx = 0
mov sp, cx ; stack pointer (cx) = 0
mov si, sp ; sp = cx = 0 -> si = 0
```

**Answer**: `si = 0`&#x20;

#### Question 4:

```nasm
mov al, 't ; 't' in hex - 0x74
mov ah, 0x0e ; ; hex(ord('t')) = '0x74'
mov ax, .string_to_print ; This is our label
```

**Answer**: `ax == 0x0e74`

#### Question 5:

```nasm
mov ax, .string_to_print ; string_to_print gets ax
.string_to_print: db "acOS", 0x0a, 0x0d, "by elyk", 0x00 ; db (define bytes)
mov si, ax ; si gets ax
cmp byte [si], 0 ; Compare 0 to the dereference of si (what is pointed to by si) // This is because of the brackets
je .end ; If si is = to 0, jump to .end
inc si ; increment pointer si by one // meaning, we are now in a loop
mov ah, 0x0e ; ah gets 0x0e // hex(ord('a')) = '0x61'
```

<mark style="color:yellow;">The a comes from the first letter in "acOS" from the first loop increment</mark>.&#x20;

**Answer**: `ax = 0x0e61` after the first loop!

