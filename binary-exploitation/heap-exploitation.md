---
description: 10/12/2023
cover: https://www.gifcen.com/wp-content/uploads/2021/02/demon-slayer-gif-2.gif
coverY: 222
---

# ðŸ§Ÿâ™‚ Heap Exploitation

## Introduction

#### What is the <mark style="color:yellow;">heap</mark>?

This is an area of memory that is used for dynamic allocation.

* This is allocated space that is unknown at compile time

**(e.g.):** `malloc()` -- Consists of a lot of functionality behind how it operates in order to do its job of space and runtime complexity.

* As a result, this gives us a large attack surface
* We could achieve a null-byte overflow that can lead to RCE

> _**In order to attack the heap, you must understand how certain parts of the heap works.**_

<figure><img src="../.gitbook/assets/image (173).png" alt=""><figcaption></figcaption></figure>

* The text section consists of machine instructions
* The heap is dynamic data
* The stack consists of static data

### Important Note

The <mark style="color:yellow;">Stack</mark> is handled/managed by the <mark style="color:yellow;">compiler</mark>.

The <mark style="color:yellow;">Heap</mark> is handled/managed by the <mark style="color:yellow;">programmer</mark>.

### `Malloc()`/`Calloc()`

Both located within the `libc` library.

## `LD_PRELOAD`

This is a <mark style="color:yellow;">Linux feature</mark> within the <mark style="color:yellow;">Dynamic Linker</mark> that <mark style="color:green;">allows users to preload shared object files into the address space of a process prior to execution</mark>.

<mark style="color:yellow;">Different versions of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`libc`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">will mean different versions of standard functions. Ultimately, leading to different behaviors in the heap</mark>.

During exploitation, be sure you are using the right `libc` version.

We can use `LD_PRELOAD` for this.

This will first load shared libraries that are in `LD_PRELOAD`.

However, in secure-execution mode, entries in `LD_PRELOAD` can be ignored.

{% embed url="https://stackoverflow.com/questions/426230/what-is-the-ld-preload-trick" %}

{% embed url="https://www.baeldung.com/linux/ld_preload-trick-what-is" %}

> _**"The `LD_PRELOAD`**_ _<mark style="color:yellow;">**trick is a useful technique to influence the linkage of shared libraries and the resolution of symbols (functions) at runtime**</mark>**. To explain**** ****`LD_PRELOAD`****, letâ€™s first discuss a bit about libraries in the Linux system.**_
>
> _**In brief, a library is a collection of compiled functions. We can make use of these functions in our programs without rewriting the same functionality. This can be achieved by either including the library code in our program (**_[_**static library**_](https://en.wikipedia.org/wiki/Static\_library)_**) or by linking dynamically at runtime (**_[_**shared library**_](https://en.wikipedia.org/wiki/Library\_\(computing\)#Shared\_libraries)_**).**_
>
> _**Using static libraries, we can build standalone programs. On the other hand, programs built with a shared library require runtime**** **<mark style="color:yellow;">**linker/loader**</mark>** ****support. For this reason, before executing a program, all required symbols are loaded and the program is prepared for execution."**_

### Use Cases

Libraries can be overwritten.

We can see `LD_PRELOAD` in action using the `ldd` command. This command is helpful for listing runtime dependencies of a binary program or shared library.&#x20;

Using `ldd`, we can a specified program's depended libraries.

Keep in mind that `LD_PRELOAD` <mark style="color:yellow;">is an environment variable and it only affects the current process</mark>.

Therefore, we will only use absolute paths.&#x20;

### Replacing Libraries Using `LD_PRELOAD`
