---
description: 08/26/2023
---

# ðŸ¥µ Format String Vulnerabilities

## Introduction

**What will we be learning?**

We will be learning how to <mark style="color:yellow;">identify</mark> and <mark style="color:yellow;">utilize</mark> **format string vulnerabilities** in programs to be able to <mark style="color:yellow;">leak addresses</mark> and <mark style="color:yellow;">other data off the stack</mark>.

### GitHub

{% embed url="https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/07-format_string_vulns" %}
Grab the target binary here and other files
{% endembed %}

### Video Tutorial

{% embed url="https://www.youtube.com/watch?v=iwNYoDw1hW4" %}
The all mighty CryptoCat
{% endembed %}

### Set Proper File Permissions

```
sudo chown root:root format_vuln
sudo chmod 4655 format_vuln -- This will set the "sticky bit"
sudo chown root:root flag.txt
sudo chmod 600 flag.txt
```

## Enumeration

`file`:

{% code overflow="wrap" %}
```
format_vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=c6e50d7e3fe3796407a1827f21d01f343dbaf3fa, for GNU/Linux 3.2.0, not stripped
```
{% endcode %}

* 32-bit
* Dynamically linked to `libc` library
* Not stripped

`checksec`:

```
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

* <mark style="color:green;">NX Enabled</mark>

## "Messing around with the program"

Something that you want to get into the habit of, is <mark style="color:yellow;">**simply just running the binary and asking yourself**</mark> "<mark style="color:yellow;">what is the program doing? What is the point of the program? What conditions is it requiring?</mark>"

These types of questions will help you gain a serious level of situational awareness and allow you to better process what is happening on the stack while looking at assembly, when looking at decompilation, etc.

<figure><img src="../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure>

Okay, we can see that we are likely using `printf()` to be able to print out our STDIN.

Also, <mark style="color:yellow;">notice how we cannot overflow the buffer</mark>, is `fgets()` <mark style="color:yellow;">being used to check against the size of the buffer</mark>?

It also appears that we are in some type of loop.

## Reversing

I know that the video highlights source code analysis, but often we find ourselves in the situation more times than not with just the binary alone and no source code.

Load up the binary in Ghidra.

Decompilation of `main() variables and conversions have been made`:

```c
void main(void)

{
  char buffer_1 [64];
  char buffer_2 [64];
  FILE *local_1c;
  __gid_t local_18;
  char *local_14;
  undefined *puStack_10;
  
  puStack_10 = &stack0x00000004;
  setvbuf(_stdout,(char *)0x0,2,0);
  local_14 = buffer_1;
  local_18 = getegid();
  setresgid(local_18,local_18,local_18);
  puts("We will evaluate any format string you give us with printf().");
  local_1c = fopen("flag.txt","r");
  if (local_1c == (FILE *)0x0) {
     puts("flag.txt is missing!");
                         /* WARNING: Subroutine does not return */
     exit(0);
  }
  fgets(buffer_1,64,local_1c);
  do {
     printf("> ");
     fgets(buffer_2,64,_stdin);
     printf(buffer_2);
  } while( true );
}
```

Convert the original `0x40` in `fgets()` to decimal and you will see that it is taking the `sizeof()` our buffer (which is of 64-bytes). It will be converted to hex `0x40` to `64` decimal.

Renamed variables pertaining to buffers to be easier to read:

<figure><img src="../.gitbook/assets/image (118).png" alt=""><figcaption></figcaption></figure>

* Both buffers are of 64-bytes
  * We see a variable that is being pointed to something (\*)
* `fopen()` is pointing to a file descriptor and opening it in memory, could this be our flag?
* Here, we aren't using `gets()`, but rather `fgets()` which is not a dangerous function because it is only going to read the flag size of 64-bytes
* We will then use `printf()` to display "`>`" to act as a console
* `fgets()` will then utilize `_stdin` to take in our STDIN/input&#x20;
* We then see that `fgets()` is taking the `sizeof()` our buffer of 64-bytes. There is no vulnerability here because it is checking STDIN is of 64-bytes.
* Lastly, we see `printf(buffer_2)` which is <mark style="color:yellow;">where our vulnerability can be found</mark>
* Also, I felt it was important to mention that we will be looping while true, giving us an infinite loop, never-ending program

## Vulnerability

The vulnerability lies in the `printf()` call itself.

Anytime that you take input from the user, you MUST specify which type of data you are expecting it to be.&#x20;

This must be supplied to `printf()` as an argument, or it will result in a Format String Vulnerability.&#x20;

In other words, <mark style="color:yellow;">if the developer does NOT specify a format specifier</mark>, <mark style="color:yellow;">the attacker can supply one for the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`printf()`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">call</mark>.

Check out this diagram to <mark style="color:yellow;">view what format specifiers look like in C</mark>:

| Format Specifier | Type                          |
| ---------------- | ----------------------------- |
| %c               | Character                     |
| %d               | Signed integer                |
| %e or %E         | Scientific notation of floats |
| %f               | Float values                  |
| %g or %G         | Similar as %e or %E           |
| %hi              | Signed integer (short)        |
| %hu              | Unsigned Integer (short)      |
| %i               | Unsigned integer              |
| %l or %ld or %li | Long                          |
| %lf              | Double                        |
| %Lf              | Long double                   |
| %lu              | Unsigned int or unsigned long |
| %lli or %lld     | Long long                     |
| %llu             | Unsigned long long            |
| %o               | Octal representation          |
| %p               | Pointer                       |
| %s               | String                        |
| %u               | Unsigned int                  |
| %x or %X         | Hexadecimal representation    |
| %n               | Prints nothing                |
| %%               | Prints % character            |

## Leaking Values off the Stack

**Keep in mind that we can literally print anything from the stack with this vulnerability.**

**This includes:**

* Global Offset Table (GOT)

### Manual Method

So, with the Format String Vulnerability identified, <mark style="color:yellow;">since the attacker can supply their own format specifier</mark>, <mark style="color:yellow;">let's do so</mark>:

<figure><img src="../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure>

1. We sent <mark style="color:yellow;">`%p`</mark> and was able to <mark style="color:yellow;">return pointers</mark>.
2. We sent <mark style="color:yellow;">`%x`</mark> and was able to <mark style="color:yellow;">return hex values</mark>.
3. We sent <mark style="color:yellow;">`%c`</mark> and was able to <mark style="color:yellow;">return char values</mark>.

If we tried to simply print out the values as a string using a string format specifier, we would segmentation fault.

Why is that?

This is because it will try to print the value as a pointer which will lead to an address that is not within the program's memory range, leading to a program crash and segmentation fault.

<figure><img src="../.gitbook/assets/image (122).png" alt=""><figcaption></figcaption></figure>

This can also be explained as `%s` treating the data on the stack as an address to go grab the string from. This is also known as <mark style="color:yellow;">**pass by reference**</mark>**.**

<mark style="color:yellow;">**This means that we could even read from any address, even if the data is not located on the stack**</mark>**.**

This is all stemming from the fact that we fully control the format string.

**What is the data in these values?**

We can use `unhex` to <mark style="color:yellow;">convert these values because they are all hex values</mark>!

```
unhex 67616c66
galf
```

Interesting, that's **flag** backwards. It's represented this way due to little-endian.

I wonder if we can find our flag in memory by leaking values from the stack :thinking:.

### Positional Arguments with `printf()`

Notice how `67616c66` is our <mark style="color:yellow;">fifth element that was printed</mark>.

If we use `printf()`'s positional arguments, we can print that exact value:

```
%5$x
67616c66

%5$x
0x67616c66
```

Interesting. Let's see if we can print out the entire flag from this leak.
