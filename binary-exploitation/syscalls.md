---
description: 09/21/2023
---

# ðŸ“² Syscalls

## Introduction

A <mark style="color:yellow;">**syscall**</mark> is a <mark style="color:yellow;">**system call**</mark>.

This is how the program enters the kernel in order to carry out a specific task such as creating a process, Input and Output, and other tasks that require kernel-level access.

**Check out the Linux Syscall Table:**

{% embed url="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md#x86_64-64_bit" %}

You will come to notice that syscalls are very similar in appearance to `libc` functions.

* `open()`
* `fork()`
* `read()`

Ultimately, these functions can be summed up as wrappers around syscalls, making it easier for programmers to utilize in code.

## How to Trigger Syscalls

In Linux, <mark style="color:yellow;">syscalls are triggered by using the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`int80`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">instruction</mark>.

Once called, <mark style="color:yellow;">the kernel checks the value stored in</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`RAX`</mark> and this is <mark style="color:yellow;">equivalent to the syscall number which is what depicts</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">**WHICH**</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">syscall is ran</mark>.

## `Execve`

The `execve` syscall executes the program passed to it in the RDI register.

`RSI` and `RDX` hold `argp` and `envp` respectively.

* <mark style="color:yellow;">`argp`</mark> are <mark style="color:yellow;">command line arguments</mark>
* <mark style="color:yellow;">`envp`</mark> are <mark style="color:yellow;">environment variables</mark>

#### What does this mean?

If there is no `system()` funciton, we can use `execve` to call `"/bin/sh"` instead.

<mark style="color:yellow;">This will pass in a pointer</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`"/bin/sh"`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`RDI`</mark><mark style="color:yellow;">, populating the</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`RSI`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`RDX`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">with</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">since both</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`argv`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">and</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`envp`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">need to have the value of</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`NULL`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">to grant you a shell</mark>.

## Additional Context

<mark style="color:yellow;">Kernel-based malware and exploits require syscalls</mark> in order to intercept file read/writes, open sockets for network communications, creating files, read/write memory, etc.
