---
description: 06/26/2024
cover: >-
  https://media1.giphy.com/media/Rpl1sod1vCXK0L2SUN/giphy.gif?cid=6c09b952c5h85x7hivle16v9l4zgdsrwbqaflsgsqzw1suj1&ep=v1_gifs_search&rid=giphy.gif&ct=g
coverY: -8
---

# üîç Pinpointing Low-Level Bugs in Android: Heap Exploitation

## Introduction

<mark style="color:yellow;">Attacking dynamic memory region vulnerabilities!</mark>

{% hint style="info" %}
:rotating\_light: **Let me just start this one off as a preface:**&#x20;

**Wow, if you thought heap exploitation was crazy before, just wait until you finish reading this one.**
{% endhint %}

### References

{% embed url="https://www.synacktiv.com/en/publications/exploring-android-heap-allocations-in-jemalloc-new" %}
Synack
{% endembed %}

{% embed url="https://ir0nstone.gitbook.io/notes/types/heap" %}
ir0nstone
{% endembed %}

## What is Heap Spraying and Heap Grooming?

Wait, [Heap Feng Shui](https://en.wikipedia.org/wiki/Heap\_feng\_shui)?

{% hint style="info" %}
:biohazard: **This is an "Exploit Delivery Technique".**
{% endhint %}

This helps an attacker to be able to replace newly freed objects with objects of the attacker's choice.

Knowing information and sizing ahead of time will allow us to overwrite important objects on the heap.&#x20;

* This really comes in handy with attacks such as [Use-After-Free](../../binary-exploitation/heap-exploitation/use-after-free.md) (UAF's)

### Why so Prevalent in a UAF Attack?

This is because when an object becomes freed (`free()`), the location itself is now freed, but the object pointer still remains available to the attacker. This is known as a dangling pointer. I always pictured dangling pointers as being similar to the [_**Anglerfish**_](https://en.wikipedia.org/wiki/Anglerfish) that can be found within the deepest parts of the ocean, known as abysses. Better yet, a _**Danglerfish**_ :wink:.

Simply put, a dangling pointer is a pointer that has been recently freed but it's still a pointer that points to invalid data. <mark style="color:red;">This can lead to unexpected results or code execution</mark>.&#x20;

<figure><img src="../../.gitbook/assets/image (211).png" alt=""><figcaption><p>Depiction of a dangling pointer. -- Danglerfish</p></figcaption></figure>



### Allocation Size Classes

<figure><img src="../../.gitbook/assets/image (209).png" alt=""><figcaption><p>Different allocation regions when allocating memory with JEMalloc</p></figcaption></figure>

### How Does This Work?

**Given the following C code:**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    size_t size = 1337; // Number of bytes to allocate
    void *ptr;

    // Allocate memory dynamically for 512 bytes
    ptr = malloc(size);

    if (ptr == NULL) {
        printf("Memory allocation failed\n");
        return 1;
    }

    printf("Memory allocated successfully: %zu bytes\n", size);

    // Free the allocated memory
    free(ptr);

    return 0;
}
```

**Output:**

```
Memory allocated successfully: 1337 bytes
```

We have allocated 1,337-bytes of data within the heap memory region of the virtual process space.

This means that we our object will be stored within the 22nd bucket with a max of 1,536 bytes that can be allocated. It can't be stored in the 21st bucket as it is only optimized for 1,280-bytes, not enough for 1,337.

This means when we are spraying the heap, we'll be able to spray for the same sized object.
