---
description: 07/18/2023
---

# 4⃣ Stack Four

> Stack Four takes a look at what can happen when you can overwrite the saved instruction pointer (standard buffer overflow).

#### **Hints**

* The saved instruction pointer is not necessarily directly after the end of variable allocations – things like compiler padding can increase the size. [Did you know that some architectures may not save the return address on the stack in all cases?](https://en.wikipedia.org/wiki/Link\_register)
* GDB supports “run < my\_file” to direct input from my\_file into the program.

## Source Code

<pre class="language-c"><code class="lang-c">/*
 * phoenix/stack-four, by https://exploit.education
 *
 * The aim is to execute the function complete_level by modifying the
 * saved return address, and pointing it to the complete_level() function.
 *
 * Why were the apple and orange all alone? Because the bananna split.
 */

#include &#x3C;err.h>
#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#include &#x3C;string.h>
#include &#x3C;unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

<strong>void complete_level() {
</strong>  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
</code></pre>

Sounds like we will <mark style="color:yellow;">executing a classic buffer overflow by modifying the saved</mark> <mark style="color:yellow;"></mark><mark style="color:yellow;">**return address**</mark> and pointing it to the `complete_level()` function.

## Source Code Analysis

```c
char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

We can see that `char` is acting as a pointer for `gets()`, meaning whatever we input will be stored somewhere. In this case, the 64-byte buffer (`buffer[64]`). This is achieved with `gets(buffer)`.

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

## GDB

Let's find out where the saved return address is:

