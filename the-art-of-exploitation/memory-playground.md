---
description: 06/28/2023
---

# Memory Playground

## What is this one about?

Here, we will be taking an ultra simplified program in C, compiling it, and run it through <mark style="color:yellow;">Ghidra</mark>, <mark style="color:yellow;">x64dbg</mark>, and <mark style="color:yellow;">GDB</mark>.

<mark style="color:yellow;">The motivation behind this is to one day become better with understanding memory and programming. Ultimately, leading to getting into binary exploitation</mark>.

<mark style="color:red;">Note</mark>: I will be doing this on Windows at first.

## Our simple little program

helloWorld.c:

```c
#include <stdio.h>

int main()
{

    int i;
    for (i=0; i < 3; i++)          // This will loop 3 times
    puts("Hello world!\n");     // puts() will write a string to stdout up to but not including the null char
    puts("Now exiting the program!\n");
    
    return 0;

}
```

### Compiling

When compiling:

* DO: Be sure to <mark style="color:green;">include debugging symbols</mark> with compilation via `-g`
* DON'T: Be sure to <mark style="color:red;">not</mark> strip the binary using `-s`

```
gcc -g helloWorld.c -o helloWorld.exe
```

Great, we now have a compiled Hello World program that simply prints "Hello world" to the console and is repeated three times due to our for loop. Lastly, it starts a new line before terminating the program (returning 0 from our `main()`)

### `GDB` Debugging

Now, it's time to throw our little program into our debugger using `gdb`!

<mark style="color:yellow;">`-q`</mark>: will include our source code from our program and include symbols

<mark style="color:yellow;">`set disassembly-flavor intel`</mark>: Will set debugging syntax in an Intel format

<mark style="color:yellow;">`disas main`</mark>: will dump **ASM** code for our `main()` function

<mark style="color:yellow;">`b main`</mark>: will place breakpoint and pause execution at `main()`

```c
gdb -q .\helloWorld.exe
Reading symbols from .\helloWorld.exe...
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
   0x0000000140001450 <+0>:     push   rbp
   0x0000000140001451 <+1>:     mov    rbp,rsp
   0x0000000140001454 <+4>:     sub    rsp,0x30
   0x0000000140001458 <+8>:     call   0x140001550 <__main>
   0x000000014000145d <+13>:    mov    DWORD PTR [rbp-0x4],0x0
   0x0000000140001464 <+20>:    jmp    0x140001479 <main+41>
   0x0000000140001466 <+22>:    lea    rax,[rip+0x2b93]        # 0x140004000
   0x000000014000146d <+29>:    mov    rcx,rax
   0x0000000140001470 <+32>:    call   0x140002648 <puts>
   0x0000000140001475 <+37>:    add    DWORD PTR [rbp-0x4],0x1
   0x0000000140001479 <+41>:    cmp    DWORD PTR [rbp-0x4],0x2
   0x000000014000147d <+45>:    jle    0x140001466 <main+22>
   0x000000014000147f <+47>:    lea    rax,[rip+0x2b88]        # 0x14000400e
   0x0000000140001486 <+54>:    mov    rcx,rax
   0x0000000140001489 <+57>:    call   0x140002648 <puts>
   0x000000014000148e <+62>:    mov    eax,0x0
   0x0000000140001493 <+67>:    add    rsp,0x30
   0x0000000140001497 <+71>:    pop    rbp
   0x0000000140001498 <+72>:    ret
End of assembler dump.
(gdb) b main
Breakpoint 1 at 0x14000145d: file .\helloWorld.c, line 7.
(gdb)
```

### Examining Strings at Memory Addresses

In `gdb`, we can use `x/s` for this.

<figure><img src="../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

We can see that we are able to see our strings here:

```c
(gdb) x/s 0x140004000
0x140004000:    "Hello world!\n"
(gdb) x/s 0x14000400e
0x14000400e:    "Now exiting the program!\n"
(gdb)
```

We are also able to see that our `main()` has the memory address of <mark style="color:yellow;">`0x130001550`</mark>.

<figure><img src="../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

This means that we were able to locate our entrypoint in **Ghidra** as well using this address.&#x20;

Not only were we able to use the address, but we were also able to use the `__main` symbol to locate it as well.&#x20;

Returning back to `gdb`, let's continue with the flow of our execution:

```c
(gdb) run
Starting program: C:\Users\User\Desktop\projects\C\helloWorld.exe
[New Thread 10620.0x2f90]

Thread 1 hit Breakpoint 1, main () at .\helloWorld.c:7
7           for (i=0; i < 3; i++)          // This will loop 3 times
```
