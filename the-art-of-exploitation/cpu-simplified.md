---
description: 06/26/2023
---

# CPU Simplified

## Simply put...

All a CPU can really do in the end is obtain machine code via a compiled program (turn source code into machine code), use the machine code to obtain instructions on how to move memory for the intended operation, perform some sort of math, potentially interrupt the processor, and lastly get it to do something else.

## Registers

Processors have their own set of special variables called registers.

Most of the instructions use these registers to read or write data.

* It is imperative to understand registers to understand instructions

### x64 CPU Registers

The x64 CPU has eight different registers. These are like internal variables for the processor.&#x20;

Please go over the reference sheet when looking through the debugger output for a better understanding of what is going on.&#x20;

{% embed url="https://web.stanford.edu/class/cs107/resources/x86-64-reference.pdf" %}

### What is GDB? -- Debuggers

Debuggers are used by programmers to step through compiled programs, examine program memory, and view processor registers.

<mark style="color:yellow;">Why are they so important and so powerful?</mark>

Similar to a microscope, a debugger allows a hacker to observe the microscopic world of machine code. However, it is far more powerful than that. A debugger allows the hacker to be able to view the execution from all angles, pause it, and change anything along the way.

How can we see these variables visually to best learn about them?

* Let's use `gdb`

```
gdb -q ./helloWorld.exe
Reading symbols from .\helloWorld.exe...
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 7456.0xdf8]
Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

[Thread 7456.0xdf8 exited with code 0]
[Inferior 1 (process 7456) exited normally]
(gdb)
```

### Breakpoints

The breakpoint will stop execution right on main so that no code will execute yet.

This will allow us to pause execution and be able to display all registers and their current states.

Let's view the state of the processor registers right before the program starts:

```
(gdb) break main
Breakpoint 1 at 0x7ff74097145d: file C:\Users\Xyconix\Desktop\projects\C\helloWorld.c, line 7.
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 8688.0x514]

Thread 1 hit Breakpoint 1, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:7
7           for (i=0; i < 10; i++)          // This will loop 10 times
(gdb)
```

* Notice how since there is a loop in the `main()`, you will need to use `n` to execute the next instruction
* Since there are 10 loops, <mark style="color:yellow;">you need to execute it 10 times</mark>
* We can also use `info registers` to view the state of the processor registers at that time of execution

```
gdb -q .\helloWorld.exe
Reading symbols from .\helloWorld.exe...
(gdb) break main
Breakpoint 1 at 0x14000145d: file C:\Users\Xyconix\Desktop\projects\C\helloWorld.c, line 7.
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 9552.0x608]

Thread 1 hit Breakpoint 1, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:7
7           for (i=0; i < 10; i++)          // This will loop 10 times
(gdb) info registers
rax            0x1                 1
rbx            0x8                 8
rcx            0x1                 1
rdx            0xb415f0            11802096
rsi            0x33                51
rdi            0xb415f8            11802104
rbp            0x5ffea0            0x5ffea0
rsp            0x5ffe70            0x5ffe70
r8             0xb41c90            11803792
r9             0x7ffb865f6850      140718267918416
r10            0x0                 0
r11            0x5ffd08            6290696
r12            0xb41630            11802160
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x7ff74097145d      0x7ff74097145d <main+13>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x53                83
gs             0x2b                43
(gdb)
```

### x64 Registers

Inside of `gdb`, run: <mark style="color:green;">`set disassembly-flavor intel`</mark> to set the <mark style="color:yellow;">disassembly to be in an intel syntax</mark>.&#x20;

<figure><img src="../.gitbook/assets/image (8).png" alt=""><figcaption><p>x64 Registers</p></figcaption></figure>

`%rip`: Instruction Pointer

`%rsp`: Stack Pointer

`%rax`: Return Value

`%rbp`: Base Pointer

These registers are known as general-purpose registers. They are responsible for executing machine instructions. `%rip` and `%rsp` <mark style="color:yellow;">are called pointers because they store 32-bit respectively and point to that location in memory. They are VERY important to program execution and memory management.</mark>&#x20;

The <mark style="color:yellow;">Instruction Pointer</mark> points to the current instruction that the processor is reading.

The <mark style="color:yellow;">Stack Pointer</mark> is used to keep track of the top of the stack in the program's memory. It points to the most recently pushed value onto the stack.

The <mark style="color:yellow;">Base Pointer</mark> is used as a reference or base pointer in stack-based operations. It is often used to access function parameters, local variables, and saved registers within a function's stack name. The RBP usually stays the same throughout execution while the RSP changes as the stack grows and shrinks.

In short, the <mark style="color:yellow;">RSP</mark> keeps track of the top of the stack and manages stack operations.

The <mark style="color:yellow;">RBP</mark> is used as a fixed reference point within the stack frame for accessing local variables and function parameters.

I was curious about how the return value works.

On line 12 of our helloWorld.c program, I have a `return 0`, so I placed a `break 12` point on this line using \`breaklet's see what this looks like in `gdb:`

```
Thread 1 hit Breakpoint 2, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:12
12          return 0;
(gdb) info registers
rax            0x0                 0
rbx            0x8                 8
rcx            0xffffffff          4294967295
rdx            0x7ffb84f7fa30      140718244362800
rsi            0x33                51
rdi            0x1c15f8            1840632
rbp            0x5ffea0            0x5ffea0
rsp            0x5ffe70            0x5ffe70
r8             0x7ffb84f85940      140718244387136
r9             0x5fe2e0            6284000
r10            0x0                 0
r11            0x246               582
r12            0x1c1630            1840688
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x7ff74097147f      0x7ff74097147f <main+47>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x53                83
gs             0x2b                43
```

You can see that `%rax` has a value of `0`, hence `return 0` on line 12!!!!

How cool is that?

### Let's simplify our code...

helloWorld.c:

```c
#include <stdio.h>

int main()
{
    puts("Hello world!\n");
    
    return 0;
}
```

Dump ASM for main function:

```
Reading symbols from .\helloWorld.exe...
(gdb) b 8
Breakpoint 1 at 0x14000145d: file .\helloWorld.c, line 8.

(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 460.0x2cb8]

(gdb) set disassembly-flavor intel

(gdb) disas main
Dump of assembler code for function main:
   0x00007ff71cd01450 <+0>:     push   rbp
   0x00007ff71cd01451 <+1>:     mov    rbp,rsp
   0x00007ff71cd01454 <+4>:     sub    rsp,0x20
   0x00007ff71cd01458 <+8>:     call   0x7ff71cd01530 <__main>
=> 0x00007ff71cd0145d <+13>:    lea    rax,[rip+0x2b9c]        # 0x7ff71cd04000
   0x00007ff71cd01464 <+20>:    mov    rcx,rax
   0x00007ff71cd01467 <+23>:    call   0x7ff71cd02628 <puts>
   0x00007ff71cd0146c <+28>:    mov    eax,0x0
   0x00007ff71cd01471 <+33>:    add    rsp,0x20
   0x00007ff71cd01475 <+37>:    pop    rbp
   0x00007ff71cd01476 <+38>:    ret
End of assembler dump.
```

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p>Utilizing x/s to look into data</p></figcaption></figure>

We can verify our **"Hello world!"** string is located within the address <mark style="color:yellow;">`0x7ff71cd04000`</mark>

What is x/s? x = hexadecimal and s = string.

### Operations

Intel syntax will generally follow this style:

```
operation <destination>, <source>
```

There are operations that are used to control the flow of execution.

The `cmp` <mark style="color:yellow;">operation is used to compare values and basically any operation with j is used to jump to a different part of code</mark>.
