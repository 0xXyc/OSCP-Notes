---
description: 06/26/2023
---

# CPU Simplified

## Simply put...

All a CPU can really do in the end is obtain machine code via a compiled program (turn source code into machine code), use the machine code to obtain instructions on how to move memory for the intended operation, perform some sort of math, potentially interrupt the processor, and lastly get it to do something else.

## Registers

Processors have their own set of special variables called registers.

Most of the instructions use these registers to read or write data.

* It is imperative to understand registers to understand instructions

### x64 CPU Registers

The x64 CPU has eight different registers. These are like internal variables for the processor.&#x20;

Please go over the reference sheet when looking through the debugger output for a better understanding of what is going on.&#x20;

{% embed url="https://web.stanford.edu/class/cs107/resources/x86-64-reference.pdf" %}

### What is GDB? -- Debuggers

Debuggers are used by programmers to step through compiled programs, examine program memory, and view processor registers.

<mark style="color:yellow;">Why are they so important and so powerful?</mark>

Similar to a microscope, a debugger allows a hacker to observe the microscopic world of machine code. However, it is far more powerful than that. A debugger allows the hacker to be able to view the execution from all angles, pause it, and change anything along the way.

How can we see these variables visually to best learn about them?

* Let's use `gdb`

```
gdb -q ./helloWorld.exe
Reading symbols from .\helloWorld.exe...
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 7456.0xdf8]
Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

Hello world!

[Thread 7456.0xdf8 exited with code 0]
[Inferior 1 (process 7456) exited normally]
(gdb)
```

### Breakpoints

The breakpoint will stop execution right on main so that no code will execute yet.

This will allow us to pause execution and be able to display all registers and their current states.

Let's view the state of the processor registers right before the program starts:

```
(gdb) break main
Breakpoint 1 at 0x7ff74097145d: file C:\Users\Xyconix\Desktop\projects\C\helloWorld.c, line 7.
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 8688.0x514]

Thread 1 hit Breakpoint 1, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:7
7           for (i=0; i < 10; i++)          // This will loop 10 times
(gdb)
```

* Notice how since there is a loop in the `main()`, you will need to use `n` to execute the next instruction
* Since there are 10 loops, <mark style="color:yellow;">you need to execute it 10 times</mark>
* We can also use `info registers` to view the state of the processor registers at that time of execution

```
gdb -q .\helloWorld.exe
Reading symbols from .\helloWorld.exe...
(gdb) break main
Breakpoint 1 at 0x14000145d: file C:\Users\Xyconix\Desktop\projects\C\helloWorld.c, line 7.
(gdb) run
Starting program: C:\Users\Xyconix\Desktop\projects\C\helloWorld.exe
[New Thread 9552.0x608]

Thread 1 hit Breakpoint 1, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:7
7           for (i=0; i < 10; i++)          // This will loop 10 times
(gdb) info registers
rax            0x1                 1
rbx            0x8                 8
rcx            0x1                 1
rdx            0xb415f0            11802096
rsi            0x33                51
rdi            0xb415f8            11802104
rbp            0x5ffea0            0x5ffea0
rsp            0x5ffe70            0x5ffe70
r8             0xb41c90            11803792
r9             0x7ffb865f6850      140718267918416
r10            0x0                 0
r11            0x5ffd08            6290696
r12            0xb41630            11802160
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x7ff74097145d      0x7ff74097145d <main+13>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x53                83
gs             0x2b                43
(gdb)
```

### x64 Registers

Inside of `gdb`, run: set `disassembly-flavor intel` to set the disassembly to be in an intel syntax.&#x20;

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p>x64 Registers</p></figcaption></figure>

`%rip`: Instruction pointer

`%rsp`: Stack pointer

`%rax`: Return value

These registers are known as general-purpose registers. They are responsible for executing machine instructions. `%rip` and `%rsp` <mark style="color:yellow;">are called pointers because they store 32-bit respectively and point to that location in memory. They are VERY important to program execution and memory management.</mark>&#x20;

The Instruction Pointer points to the current instruction that the processor is reading.

The Stack Pointer&#x20;

I was curious about how the return value works.

On line 12 of our helloWorld.c program, I have a `return 0`, so I placed a `break 12` point on this line using \`breaklet's see what this looks like in `gdb:`

```
Thread 1 hit Breakpoint 2, main () at C:\Users\Xyconix\Desktop\projects\C\helloWorld.c:12
12          return 0;
(gdb) info registers
rax            0x0                 0
rbx            0x8                 8
rcx            0xffffffff          4294967295
rdx            0x7ffb84f7fa30      140718244362800
rsi            0x33                51
rdi            0x1c15f8            1840632
rbp            0x5ffea0            0x5ffea0
rsp            0x5ffe70            0x5ffe70
r8             0x7ffb84f85940      140718244387136
r9             0x5fe2e0            6284000
r10            0x0                 0
r11            0x246               582
r12            0x1c1630            1840688
r13            0x0                 0
r14            0x0                 0
r15            0x0                 0
rip            0x7ff74097147f      0x7ff74097147f <main+47>
eflags         0x202               [ IF ]
cs             0x33                51
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x53                83
gs             0x2b                43
```

You can see that `%rax` has a value of `0`, hence `return 0` on line 12!!!!

How cool is that?

### Operations

There are operations that are used to control the flow of execution.

The `cmp` <mark style="color:yellow;">operation is used to compare values and basically any operation with j is used to jump to a different part of code</mark>.
